<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>hikari.impl.event_manager_base API documentation</title>
<meta name="description" content="A base implementation for an event manager.">
<meta property="og:title" content="hikari.impl.event_manager_base module list">
<meta property="og:type" content="website">
<meta property="og:image" content="https://hikari-py.dev/logo.png">
<meta property="og:description" content="A Discord Bot framework for modern Python and asyncio built on good intentions">
<meta property="theme-color" content="#ff029a">
<link rel="shortcut icon" type="image/png" href="../../logo.png">
<!--<script async src="https://cse.google.com/cse.js?cx=017837193012385208679:pey8ky8gdqw"></script>
<style>.gsc-control-cse {padding:0 !important;margin-top:1em}</style>-->
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css">
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" rel="stylesheet">
<style>
img#logo {
border-radius: 15px;
width: 30px;
height: 30px;
margin-right: 0.5em;
text-indent: 100%;
white-space: nowrap;
overflow: hidden;
}
small.smaller {
font-size: 0.50em;
}
html {
height: 100%;
scroll-behavior: smooth;
scrollbar-color: #202324 #454a4d;
}
body {
background-color: #181A1B;
color: #C9C5C0;
height: fit-content;
}
h1 {
margin-top: 3rem;
}
h2 {
margin-top: 1.75rem;
margin-bottom: 1em;
}
h3 {
margin-top: 1.25rem;
}
h4 {
margin-top: 1rem;
}
.nav-section {
margin-top: 2em;
}
.monospaced {
font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}
a.sidebar-nav-pill,
a.sidebar-nav-pill:active,
a.sidebar-nav-pill:hover {
color: #BDB7AF;
}
.module-source > details > pre {
display: block;
overflow-x: auto;
overflow-y: auto;
max-height: 600px;
font-size: 0.8em;
}
a {
color: #DE4F91;
}
a:hover {
color: #64B1F2;
}
.container > li {
margin-left: 1em;
margin-top: 2.5em;
}
.jumbotron {
background-color: #232627;
}
.breadcrumb-item.inactive > a {
color: #d264d0 !important;
}
.breadcrumb-item.active > a {
color: #de4f91 !important;
}
.breadcrumb-item+.breadcrumb-item::before {
content: ".";
}
.module-breadcrumb {
padding-left: 0 !important;
background-color: #232627;
}
ul.nested {
margin-left: 1em;
}
h2#parameters::after {
margin-left: 2em;
}
.anchor:target {
background-color: var(--dark);
}
@media screen and (max-width: 990px) {
.anchor:target {
margin-left: -2em;
padding-left: 2em;
}
}
@media screen and (min-width: 990px) {
.anchor:target {
border-radius: 0.5em; !important
margin-right: -2em;
padding-right: 2em;
margin-top: -1em;
padding-top: 1em;
}
}
dt {
margin-left: 2em;
}
dd {
margin-left: 4em;
}
dl.no-nest > dt {
margin-left: 0em;
}
dl.no-nest > dd {
margin-left: 2em;
}
dl.root {
margin-bottom: 2em;
}
.definition {
display: block;
margin-bottom: 8em !important;
}
.definition .row {
display: block;
margin-bottom: 4em !important;
}
.definition h2 {
font-size: 1em;
font-weight: bolder;
}
.sep {
height: 2em;
}
code {
color: #DB61D9;
}
code .active {
color: #e83e8c;
}
code a {
color: #E94A93;
}
a.dotted:hover, abbr:hover {
text-decoration: underline #9E9689 dotted !important;
}
a.dotted, abbr {
text-decoration: none !important;
}
.gsc-search-box, .gsc-search-box-tools, .gsc-control-cse {
background: none !important;
border: none !important;
}
.gsc-search-button-v2, .gsc-search-button-v2:hover, .gsc-search-button-v2:focus {
color: var(--success) !important;
border-color: var(--success) !important;
background: none !important;
padding: 6px 32px !important;
font-size: inherit !important;
}
.gsc-search-button-v2 > svg {
fill: var(--success) !important;
}
.gsc-input-box {
border-radius: 3px;
}
.gsc-control-cse {
width: 300px !important;
margin-top: 0 !important;
}
.gsc-control-cse .gsc-control-cse-en {
margin-top: 0 !important;
}
.bg-dark {
background-color: #2C2F31 !important;
}
.text-muted {
color: #9E9689 !important;
}
.alert-primary {
color: #7CC3FF;
background-color: #262A2B;
border-color: #003B7B;
}
.alert-secondary {
color: #C2BCB4;
background-color: #282B2C;
border-color: #3B4042;
}
.alert-success {
color: #99E6AB;
background-color: #1A3E29;
border-color: #255A32;
}
.alert-info {
color: #8EE3F1;
background-color: #143B43;
border-color: #1E5961;
}
.alert-warning {
color: #FBD770;
background-color: #513E00;
border-color: #7B5C00;
}
.alert-danger {
color: rgb(225, 134, 143);
background-color: rgb(67, 12, 17);
border-color: rgb(104, 18, 27);
}
mark {
background-color: #333333;
border-radius: 0.1em;
color: #DB61D9;
}
</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<nav id="main-nav" class="navbar navbar-dark navbar-expand-lg bg-dark">
<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
<span class="navbar-toggler-icon"/>
</button>
<a class="navbar-brand" href="https://github.com/hikari-py/hikari"><img class="d-inline-block align-top" src="../../logo.png" id="logo" alt="hikari logo" loading="lazy"/>Hikari <small class="smaller">2.0.0.dev108</small></a>
<div class="collapse navbar-collapse" id="navbarNavDropdown">
<ul class="navbar-nav mr-auto">
<li class="nav-item"><a class="nav-link" href="../../index.html">Home</a></li>
<li class="nav-item"><a class="nav-link active" href="../../hikari/index.html">Documentation</a></li>
<li class="nav-item"><a class="nav-link" href="https://github.com/hikari-py/hikari">GitHub</a></li>
<li class="nav-item"><a class="nav-link" href="https://pypi.org/project/hikari">PyPI</a></li>
<li class="nav-item"><a class="nav-link" href="https://discord.gg/Jx4cNGG">Discord Server</a></li>
</ul>
<form class="form-inline" action="../../hikari/search.html">
<input class="form-control mr-sm-2" type="search" placeholder="Search" aria-label="Search" id="lunr-search" name="q"/>
<button class="btn btn-outline-success my-2 my-sm-0" type="submit">&gt;</button>
</form>
</div>
</nav>
<div class="jumbotron jumbotron-fluid">
<div class="container">
<h1 class="display-4"><code>
<nav aria-label="breadcrumb">
<ol class="breadcrumb module-breadcrumb">
<li class="breadcrumb-item inactive"><a title="hikari -- A sane Python framework for writing modern Discord bots …" href="../index.html"
>hikari</a></li>
<li class="breadcrumb-item inactive"><a title="hikari.impl -- Basic implementations of application components …" href="index.html"
>impl</a></li>
<li class="breadcrumb-item active"><a href="#">event_manager_base</a></li>
</ol>
</nav>
</code></h1>
<p class="lead"><p>A base implementation for an event manager.</p></p>
</div>
</div>
<div class="container-xl">
<div class="row">
<div class="d-md-none d-lg-block col-lg-5 col-xl-4">
<!--<nav class="nav" id="content-nav">-->
<h3>This module</h3>
<ul class="list-unstyled text-truncate">
<li class="text-truncate monospaced"><small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="filtered -- Add metadata to a consumer method to indicate when it should be unmarshalled and dispatched …" href="#hikari.impl.event_manager_base.filtered"
>filtered</a></li>
</ul>
<ul class="list-unstyled text-truncate">
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="EventManagerBase -- Provides functionality to consume and dispatch events …" href="#hikari.impl.event_manager_base.EventManagerBase"
>EventManagerBase</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="consume_raw_event -- Consume a raw event …" href="#hikari.impl.event_manager_base.EventManagerBase.consume_raw_event"
>consume_raw_event</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="dispatch -- Dispatch an event …" href="#hikari.impl.event_manager_base.EventManagerBase.dispatch"
>dispatch</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_listeners -- Get the listeners for a given event type, if there are any …" href="#hikari.impl.event_manager_base.EventManagerBase.get_listeners"
>get_listeners</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="listen -- Generate a decorator to subscribe a callback to an event type …" href="#hikari.impl.event_manager_base.EventManagerBase.listen"
>listen</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="stream -- Return a stream iterator for the given event and sub-events …" href="#hikari.impl.event_manager_base.EventManagerBase.stream"
>stream</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="subscribe -- Subscribe a given callback to a given event type …" href="#hikari.impl.event_manager_base.EventManagerBase.subscribe"
>subscribe</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="unsubscribe -- Unsubscribe a given callback from a given event type, if present …" href="#hikari.impl.event_manager_base.EventManagerBase.unsubscribe"
>unsubscribe</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="wait_for -- Wait for a given event to occur once, then return the event …" href="#hikari.impl.event_manager_base.EventManagerBase.wait_for"
>wait_for</a>
</li>
<br />
</ul>
</li>
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="EventStream -- An implementation of an event `EventStream` class …" href="#hikari.impl.event_manager_base.EventStream"
>EventStream</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="awaiting -- Await each item concurrently in a fixed size window …" href="../iterators.html#hikari.iterators.LazyIterator.awaiting"
>awaiting</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="chunk -- Return results in chunks of up to `chunk_size` amount of entries …" href="../iterators.html#hikari.iterators.LazyIterator.chunk"
>chunk</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="close -- Mark this streamer as closed to stop it from queueing and receiving events …" href="#hikari.impl.event_manager_base.EventStream.close"
>close</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="collect -- Collect the results into a given type and return it …" href="../iterators.html#hikari.iterators.LazyIterator.collect"
>collect</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="count -- Count the number of results …" href="../iterators.html#hikari.iterators.LazyIterator.count"
>count</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="enumerate -- Enumerate the paginated results lazily …" href="../iterators.html#hikari.iterators.LazyIterator.enumerate"
>enumerate</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="filter -- Filter the items by one or more conditions …" href="#hikari.impl.event_manager_base.EventStream.filter"
>filter</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="flat_map -- Perform a flat mapping operation …" href="../iterators.html#hikari.iterators.LazyIterator.flat_map"
>flat_map</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="for_each -- Pass each value to a given consumer immediately." href="../iterators.html#hikari.iterators.LazyIterator.for_each"
>for_each</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="last -- Return the last element of this iterator only …" href="../iterators.html#hikari.iterators.LazyIterator.last"
>last</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="limit -- Limit the number of items you receive from this async iterator …" href="../iterators.html#hikari.iterators.LazyIterator.limit"
>limit</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="map -- Map the values to a different value …" href="../iterators.html#hikari.iterators.LazyIterator.map"
>map</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="next -- Return the next element of this iterator only …" href="../iterators.html#hikari.iterators.LazyIterator.next"
>next</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="open -- Mark this streamer as opened to let it start receiving and queueing events …" href="#hikari.impl.event_manager_base.EventStream.open"
>open</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="reversed -- Return a lazy iterator of the remainder of this iterator's values reversed …" href="../iterators.html#hikari.iterators.LazyIterator.reversed"
>reversed</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="skip -- Drop the given number of items, then yield anything after …" href="../iterators.html#hikari.iterators.LazyIterator.skip"
>skip</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="skip_until -- Discard items while all conditions are False …" href="../iterators.html#hikari.iterators.LazyIterator.skip_until"
>skip_until</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="skip_while -- Discard items while all conditions are True …" href="../iterators.html#hikari.iterators.LazyIterator.skip_while"
>skip_while</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="sort -- Collect all results, then sort the collection before returning it." href="../iterators.html#hikari.iterators.LazyIterator.sort"
>sort</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="take_until -- Return each item until any conditions pass or the end is reached …" href="../iterators.html#hikari.iterators.LazyIterator.take_until"
>take_until</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="take_while -- Return each item until any conditions fail or the end is reached …" href="../iterators.html#hikari.iterators.LazyIterator.take_while"
>take_while</a>
</li>
<br />
</ul>
</li>
</ul>
<!--</nav>-->
</div>
<div class="col-xs-12 col-lg-7 col-xl-8">
<div class="row">
<div class="col module-source">
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/6dbab9a6f401bcf597997b46820717e4dd956c13/hikari/impl/event_manager_base.py#L1-L660" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# cython: language_level=3
# Copyright (c) 2020 Nekokatt
# Copyright (c) 2021-present davfsa
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the &#34;Software&#34;), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
&#34;&#34;&#34;A base implementation for an event manager.&#34;&#34;&#34;

from __future__ import annotations

__all__: typing.List[str] = [&#34;filtered&#34;, &#34;EventManagerBase&#34;, &#34;EventStream&#34;]

import asyncio
import inspect
import itertools
import logging
import typing
import warnings
import weakref

import attr

from hikari import errors
from hikari import iterators
from hikari.api import config
from hikari.api import event_manager as event_manager_
from hikari.events import base_events
from hikari.events import shard_events
from hikari.internal import aio
from hikari.internal import fast_protocol
from hikari.internal import reflect
from hikari.internal import ux

if typing.TYPE_CHECKING:
    import types

    from hikari import intents as intents_
    from hikari.api import event_factory as event_factory_
    from hikari.api import shard as gateway_shard
    from hikari.internal import data_binding

    ConsumerT = typing.Callable[
        [gateway_shard.GatewayShard, data_binding.JSONObject], typing.Coroutine[typing.Any, typing.Any, None]
    ]
    ListenerMapT = typing.Dict[
        typing.Type[event_manager_.EventT_co],
        typing.List[event_manager_.CallbackT[event_manager_.EventT_co]],
    ]
    WaiterT = typing.Tuple[
        typing.Optional[event_manager_.PredicateT[event_manager_.EventT_co]], asyncio.Future[event_manager_.EventT_co]
    ]
    WaiterMapT = typing.Dict[typing.Type[event_manager_.EventT_co], typing.Set[WaiterT[event_manager_.EventT_co]]]

    EventManagerBaseT = typing.TypeVar(&#34;EventManagerBaseT&#34;, bound=&#34;EventManagerBase&#34;)
    UnboundMethodT = typing.Callable[
        [EventManagerBaseT, gateway_shard.GatewayShard, data_binding.JSONObject],
        typing.Coroutine[typing.Any, typing.Any, None],
    ]
    _EventStreamT = typing.TypeVar(&#34;_EventStreamT&#34;, bound=&#34;EventStream[typing.Any]&#34;)

_LOGGER: typing.Final[logging.Logger] = logging.getLogger(&#34;hikari.event_manager&#34;)


@typing.runtime_checkable
class _FilteredMethodT(fast_protocol.FastProtocolChecking, typing.Protocol):
    __slots__: typing.Sequence[str] = ()

    async def __call__(self, shard: gateway_shard.GatewayShard, payload: data_binding.JSONObject, /) -&gt; None:
        raise NotImplementedError

    @property
    def __cache_components__(self) -&gt; config.CacheComponents:
        raise NotImplementedError

    @property
    def __events_bitmask__(self) -&gt; int:
        raise NotImplementedError


def _generate_weak_listener(
    reference: weakref.WeakMethod[typing.Any],
) -&gt; typing.Callable[[event_manager_.EventT], typing.Coroutine[typing.Any, typing.Any, None]]:
    async def call_weak_method(event: event_manager_.EventT) -&gt; None:
        method = reference()
        if method is None:
            raise TypeError(
                &#34;dead weak referenced subscriber method cannot be executed, try actually closing your event streamers&#34;
            )

        await method(event)

    return call_weak_method


class EventStream(event_manager_.EventStream[event_manager_.EventT]):
    &#34;&#34;&#34;An implementation of an event `EventStream` class.

    !!! note
        While calling `EventStream.filter` on an active &#34;opened&#34; event stream
        will return a wrapping lazy iterator, calling it on an inactive &#34;closed&#34;
        event stream will return the event stream and add the given predicates
        to the streamer.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (
        &#34;__weakref__&#34;,
        &#34;_active&#34;,
        &#34;_event&#34;,
        &#34;_event_manager&#34;,
        &#34;_event_type&#34;,
        &#34;_filters&#34;,
        &#34;_limit&#34;,
        &#34;_queue&#34;,
        &#34;_registered_listener&#34;,
        &#34;_timeout&#34;,
    )

    __weakref__: typing.Optional[weakref.ref[EventStream[event_manager_.EventT]]]

    def __init__(
        self,
        event_manager: event_manager_.EventManager,
        event_type: typing.Type[event_manager_.EventT],
        *,
        timeout: typing.Union[float, int, None],
        limit: typing.Optional[int] = None,
    ) -&gt; None:
        self._active = False
        self._event: typing.Optional[asyncio.Event] = None
        self._event_manager = event_manager
        self._event_type = event_type
        self._filters: iterators.All[event_manager_.EventT] = iterators.All(())
        self._limit = limit
        self._queue: typing.List[event_manager_.EventT] = []
        self._registered_listener: typing.Optional[
            typing.Callable[[event_manager_.EventT], typing.Coroutine[typing.Any, typing.Any, None]]
        ] = None
        # The registered wrapping function for the weak ref to this class&#39;s _listener method.
        self._timeout = timeout

    # These are only included at runtime in-order to avoid the model being typed as an asynchronous context manager.
    if not typing.TYPE_CHECKING:

        async def __aenter__(self: _EventStreamT) -&gt; _EventStreamT:
            # This is sync only.
            warnings.warn(
                &#34;Using EventStream as an async context manager has been deprecated since 2.0.0.dev104. &#34;
                &#34;Please use it as a synchronous context manager (e.g. with bot.stream(...)) instead.&#34;,
                category=DeprecationWarning,
                stacklevel=2,
            )

            self.open()
            return self

        async def __aexit__(
            self,
            exc_type: typing.Optional[typing.Type[BaseException]],
            exc: typing.Optional[BaseException],
            exc_tb: typing.Optional[types.TracebackType],
        ) -&gt; None:
            self.close()

    def __enter__(self: _EventStreamT) -&gt; _EventStreamT:
        self.open()
        return self

    def __exit__(
        self,
        exc_type: typing.Optional[typing.Type[BaseException]],
        exc_val: typing.Optional[BaseException],
        exc_tb: typing.Optional[types.TracebackType],
    ) -&gt; None:
        self.close()

    async def __anext__(self) -&gt; event_manager_.EventT:
        if not self._active:
            raise TypeError(&#34;stream must be started with before entering it&#34;)

        while not self._queue:
            if not self._event:
                self._event = asyncio.Event()

            try:
                await asyncio.wait_for(self._event.wait(), timeout=self._timeout)
            except asyncio.TimeoutError:
                raise StopAsyncIteration from None

            self._event.clear()

        return self._queue.pop(0)

    def __await__(self) -&gt; typing.Generator[None, None, typing.Sequence[event_manager_.EventT]]:
        return self._await_all().__await__()

    def __del__(self) -&gt; None:
        # For the sake of protecting highly intelligent people who forget to close this, we register the event listener
        # with a weakref then try to close this on deletion. While this may lead to their consoles being spammed, this
        # is a small price to pay as it&#39;ll be way more obvious what&#39;s wrong than if we just left them with a vague
        # ominous memory leak.
        if self._active:
            _LOGGER.warning(&#34;active %r streamer fell out of scope before being closed&#34;, self._event_type.__name__)
            self.close()

    async def _await_all(self) -&gt; typing.Sequence[event_manager_.EventT]:
        self.open()
        result = [event async for event in self]
        self.close()
        return result

    async def _listener(self, event: event_manager_.EventT) -&gt; None:
        if not self._filters(event) or (self._limit is not None and len(self._queue) &gt;= self._limit):
            return

        self._queue.append(event)
        if self._event:
            self._event.set()

    def close(self) -&gt; None:
        if self._active and self._registered_listener is not None:
            try:
                self._event_manager.unsubscribe(self._event_type, self._registered_listener)
            except ValueError:
                pass

            self._registered_listener = None

        self._active = False

    def filter(
        self: _EventStreamT,
        *predicates: typing.Union[typing.Tuple[str, typing.Any], typing.Callable[[event_manager_.EventT], bool]],
        **attrs: typing.Any,
    ) -&gt; _EventStreamT:
        filter_ = self._map_predicates_and_attr_getters(&#34;filter&#34;, *predicates, **attrs)
        if self._active:
            self._queue = [entry for entry in self._queue if filter_(entry)]

        self._filters |= filter_
        return self

    def open(self) -&gt; None:
        if not self._active:
            # For the sake of protecting highly intelligent people who forget to close this, we register the event
            # listener with a weakref then try to close this on deletion. While this may lead to their consoles being
            # spammed, this is a small price to pay as it&#39;ll be way more obvious what&#39;s wrong than if we just left them
            # with a vague ominous memory leak.
            reference = weakref.WeakMethod(self._listener)
            listener = _generate_weak_listener(reference)
            self._registered_listener = listener
            self._event_manager.subscribe(self._event_type, listener)
            self._active = True


def _assert_is_listener(parameters: typing.Iterator[inspect.Parameter], /) -&gt; None:
    if next(parameters, None) is None:
        raise TypeError(&#34;Event listener must have one positional argument for the event object.&#34;)

    if any(param.default is inspect.Parameter.empty for param in parameters):
        raise TypeError(&#34;Only the first argument for a listener can be required, the event argument.&#34;)


def filtered(
    event_types: typing.Union[typing.Type[base_events.Event], typing.Sequence[typing.Type[base_events.Event]]],
    cache_components: config.CacheComponents = config.CacheComponents.NONE,
    /,
) -&gt; typing.Callable[[UnboundMethodT[EventManagerBaseT]], UnboundMethodT[EventManagerBaseT]]:
    &#34;&#34;&#34;Add metadata to a consumer method to indicate when it should be unmarshalled and dispatched.

    Parameters
    ----------
    event_types
        Types of the events this raw consumer method may dispatch.
        This may either be a singular type of a sequence of types.

    Other Parameters
    ----------------
    cache_components : hikari.api.config.CacheComponents
        Bitfield of the cache components this event may make altering calls to.
        This defaults to `hikari.api.config.CacheComponents.NONE`.
    &#34;&#34;&#34;
    if isinstance(event_types, typing.Sequence):
        # dict.fromkeys is used to remove any duplicate entries here
        event_types = tuple(dict.fromkeys(itertools.chain.from_iterable(e.dispatches() for e in event_types)))

    else:
        event_types = event_types.dispatches()

    bitmask = 0
    for event_type in event_types:
        bitmask |= event_type.bitmask()

    # https://github.com/python/mypy/issues/2087
    def decorator(method: UnboundMethodT[EventManagerBaseT], /) -&gt; UnboundMethodT[EventManagerBaseT]:
        method.__cache_components__ = cache_components  # type: ignore[attr-defined]
        method.__events_bitmask__ = bitmask  # type: ignore[attr-defined]
        assert isinstance(method, _FilteredMethodT), &#34;Incorrect attribute(s) set for a filtered method&#34;
        return method  # type: ignore[unreachable]

    return decorator


@attr.define(weakref_slot=False)
class _Consumer:
    callback: ConsumerT = attr.field(hash=True)
    &#34;&#34;&#34;The callback function for this consumer.&#34;&#34;&#34;

    events_bitmask: int = attr.field()
    &#34;&#34;&#34;The registered events bitmask.&#34;&#34;&#34;

    is_caching: bool = attr.field()
    &#34;&#34;&#34;Cached value of whether or not this consumer is making cache calls in the current env.&#34;&#34;&#34;

    listener_group_count: int = attr.field(init=False, default=0)
    &#34;&#34;&#34;The number of listener groups registered to this consumer.&#34;&#34;&#34;

    waiter_group_count: int = attr.field(init=False, default=0)
    &#34;&#34;&#34;The number of waiters groups registered to this consumer.&#34;&#34;&#34;

    @property
    def is_enabled(self) -&gt; bool:
        return self.is_caching or self.listener_group_count &gt; 0 or self.waiter_group_count &gt; 0


class EventManagerBase(event_manager_.EventManager):
    &#34;&#34;&#34;Provides functionality to consume and dispatch events.

    Specific event handlers should be in functions named `on_xxx` where `xxx`
    is the raw event name being dispatched in lower-case.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (
        &#34;_consumers&#34;,
        &#34;_event_factory&#34;,
        &#34;_intents&#34;,
        &#34;_listeners&#34;,
        &#34;_waiters&#34;,
    )

    def __init__(
        self,
        event_factory: event_factory_.EventFactory,
        intents: intents_.Intents,
        *,
        cache_components: config.CacheComponents = config.CacheComponents.NONE,
    ) -&gt; None:
        self._consumers: typing.Dict[str, _Consumer] = {}
        self._event_factory = event_factory
        self._intents = intents
        self._listeners: ListenerMapT[base_events.Event] = {}
        self._waiters: WaiterMapT[base_events.Event] = {}

        for name, member in inspect.getmembers(self):
            if name.startswith(&#34;on_&#34;):
                event_name = name[3:]
                if isinstance(member, _FilteredMethodT):
                    caching = (member.__cache_components__ &amp; cache_components) != 0

                    self._consumers[event_name] = _Consumer(member, member.__events_bitmask__, caching)

                else:
                    self._consumers[event_name] = _Consumer(member, -1, cache_components != cache_components.NONE)

    def _increment_listener_group_count(
        self, event_type: typing.Type[base_events.Event], count: typing.Literal[-1, 1]
    ) -&gt; None:
        event_bitmask = event_type.bitmask()
        for consumer in self._consumers.values():
            if (consumer.events_bitmask &amp; event_bitmask) == event_bitmask:
                consumer.listener_group_count += count

    def _increment_waiter_group_count(
        self, event_type: typing.Type[base_events.Event], count: typing.Literal[-1, 1]
    ) -&gt; None:
        event_bitmask = event_type.bitmask()
        for consumer in self._consumers.values():
            if (consumer.events_bitmask &amp; event_bitmask) == event_bitmask:
                consumer.waiter_group_count += count

    def _enabled_for_event(self, event_type: typing.Type[base_events.Event], /) -&gt; bool:
        for cls in event_type.dispatches():
            if cls in self._listeners or cls in self._waiters:
                return True

        return False

    def consume_raw_event(
        self, event_name: str, shard: gateway_shard.GatewayShard, payload: data_binding.JSONObject
    ) -&gt; None:
        if self._enabled_for_event(shard_events.ShardPayloadEvent):
            payload_event = self._event_factory.deserialize_shard_payload_event(shard, payload, name=event_name)
            self.dispatch(payload_event)
        consumer = self._consumers[event_name.lower()]
        asyncio.create_task(self._handle_dispatch(consumer, shard, payload), name=f&#34;dispatch {event_name}&#34;)

    def subscribe(
        self,
        event_type: typing.Type[event_manager_.EventT_co],
        callback: event_manager_.CallbackT[event_manager_.EventT_co],
        *,
        _nested: int = 0,
    ) -&gt; None:
        if not inspect.isclass(event_type) or not issubclass(event_type, base_events.Event):
            raise TypeError(&#34;Cannot subscribe to a non-Event type&#34;)

        if not inspect.iscoroutinefunction(callback):
            raise TypeError(&#34;Cannot subscribe a non-coroutine function callback&#34;)

        # `_nested` is used to show the correct source code snippet if an intent
        # warning is triggered.
        self._check_intents(event_type, _nested)

        _LOGGER.debug(
            &#34;subscribing callback &#39;async def %s%s&#39; to event-type %s.%s&#34;,
            getattr(callback, &#34;__name__&#34;, &#34;&lt;anon&gt;&#34;),
            inspect.signature(callback),
            event_type.__module__,
            event_type.__qualname__,
        )

        try:
            self._listeners[event_type].append(callback)  # type: ignore[arg-type]
        except KeyError:
            self._listeners[event_type] = [callback]  # type: ignore[list-item]
            self._increment_listener_group_count(event_type, 1)

    def _check_intents(self, event_type: typing.Type[event_manager_.EventT_co], nested: int) -&gt; None:
        # Collection of combined bitfield combinations of intents that
        # could be enabled to receive this event.
        expected_intent_groups = base_events.get_required_intents_for(event_type)

        if expected_intent_groups:
            for expected_intent_group in expected_intent_groups:
                if (self._intents &amp; expected_intent_group) == expected_intent_group:
                    break
            else:
                expected_intents_str = &#34;, &#34;.join(map(str, expected_intent_groups))

                warnings.warn(
                    f&#34;You have tried to listen to {event_type.__name__}, but this will only ever be triggered if &#34;
                    f&#34;you enable one of the following intents: {expected_intents_str}.&#34;,
                    category=errors.MissingIntentWarning,
                    stacklevel=nested + 3,
                )

    def get_listeners(
        self,
        event_type: typing.Type[event_manager_.EventT_co],
        /,
        *,
        polymorphic: bool = True,
    ) -&gt; typing.Collection[event_manager_.CallbackT[event_manager_.EventT_co]]:
        if polymorphic:
            listeners: typing.List[event_manager_.CallbackT[event_manager_.EventT_co]] = []
            for event in event_type.dispatches():
                if subscribed_listeners := self._listeners.get(event):
                    listeners.extend(subscribed_listeners)

            return listeners

        if items := self._listeners.get(event_type):
            return items.copy()

        return []

    def unsubscribe(
        self,
        event_type: typing.Type[event_manager_.EventT_co],
        callback: event_manager_.CallbackT[event_manager_.EventT_co],
    ) -&gt; None:
        if listeners := self._listeners.get(event_type):
            _LOGGER.debug(
                &#34;unsubscribing callback %s%s from event-type %s.%s&#34;,
                getattr(callback, &#34;__name__&#34;, &#34;&lt;anon&gt;&#34;),
                inspect.signature(callback),
                event_type.__module__,
                event_type.__qualname__,
            )
            listeners.remove(callback)  # type: ignore[arg-type]
            if not listeners:
                del self._listeners[event_type]
                self._increment_listener_group_count(event_type, -1)

    def listen(
        self,
        event_type: typing.Optional[typing.Type[event_manager_.EventT_co]] = None,
    ) -&gt; typing.Callable[
        [event_manager_.CallbackT[event_manager_.EventT_co]], event_manager_.CallbackT[event_manager_.EventT_co]
    ]:
        def decorator(
            callback: event_manager_.CallbackT[event_manager_.EventT_co],
        ) -&gt; event_manager_.CallbackT[event_manager_.EventT_co]:
            nonlocal event_type

            # Avoid resolving forward references in the function&#39;s signature if
            # event_type was explicitly provided as this may lead to errors.
            if event_type is not None:
                _assert_is_listener(iter(inspect.signature(callback).parameters.values()))

            else:
                signature = reflect.resolve_signature(callback)
                params = signature.parameters.values()
                _assert_is_listener(iter(params))
                event_param = next(iter(params))

                if event_param.annotation is event_param.empty:
                    raise TypeError(&#34;Must provide the event type in the @listen decorator or as a type hint!&#34;)

                event_type = event_param.annotation

            self.subscribe(event_type, callback, _nested=1)
            return callback

        return decorator

    def dispatch(self, event: event_manager_.EventT_inv) -&gt; asyncio.Future[typing.Any]:
        if not isinstance(event, base_events.Event):
            raise TypeError(f&#34;Events must be subclasses of {base_events.Event.__name__}, not {type(event).__name__}&#34;)

        tasks: typing.List[typing.Coroutine[None, typing.Any, None]] = []

        for cls in event.dispatches():
            if listeners := self._listeners.get(cls):
                for callback in listeners:
                    tasks.append(self._invoke_callback(callback, event))

            if cls not in self._waiters:
                continue

            waiter_set = self._waiters[cls]
            for waiter in tuple(waiter_set):
                predicate, future = waiter
                if not future.done():
                    try:
                        if predicate and not predicate(event):
                            continue
                    except Exception as ex:
                        future.set_exception(ex)
                    else:
                        future.set_result(event)

                waiter_set.remove(waiter)

            if not waiter_set:
                del self._waiters[cls]
                self._increment_waiter_group_count(cls, -1)

        return asyncio.gather(*tasks) if tasks else aio.completed_future()

    def stream(
        self,
        event_type: typing.Type[event_manager_.EventT_co],
        /,
        timeout: typing.Union[float, int, None],
        limit: typing.Optional[int] = None,
    ) -&gt; event_manager_.EventStream[event_manager_.EventT_co]:
        self._check_intents(event_type, 1)
        return EventStream(self, event_type, timeout=timeout, limit=limit)

    async def wait_for(
        self,
        event_type: typing.Type[event_manager_.EventT_co],
        /,
        timeout: typing.Union[float, int, None],
        predicate: typing.Optional[event_manager_.PredicateT[event_manager_.EventT_co]] = None,
    ) -&gt; event_manager_.EventT_co:
        self._check_intents(event_type, 1)

        future: asyncio.Future[event_manager_.EventT_co] = asyncio.get_running_loop().create_future()

        try:
            waiter_set = self._waiters[event_type]
        except KeyError:
            waiter_set = set()
            self._waiters[event_type] = waiter_set
            self._increment_waiter_group_count(event_type, 1)

        pair = (predicate, future)

        waiter_set.add(pair)  # type: ignore[arg-type]
        try:
            return await asyncio.wait_for(future, timeout=timeout)
        except asyncio.TimeoutError:
            waiter_set.remove(pair)  # type: ignore[arg-type]
            if not waiter_set:
                del self._waiters[event_type]
                self._increment_waiter_group_count(event_type, -1)

            raise

    async def _handle_dispatch(
        self,
        consumer: _Consumer,
        shard: gateway_shard.GatewayShard,
        payload: data_binding.JSONObject,
    ) -&gt; None:
        if not consumer.is_enabled:
            name = consumer.callback.__name__
            _LOGGER.log(
                ux.TRACE, &#34;Skipping raw dispatch for %s due to lack of any registered listeners or cache need&#34;, name
            )
            return

        try:
            await consumer.callback(shard, payload)
        except asyncio.CancelledError:
            # Skip cancelled errors, likely caused by the event loop being shut down.
            pass
        except errors.UnrecognisedEntityError:
            _LOGGER.debug(&#34;Event referenced an unrecognised entity, discarding&#34;)
        except BaseException as ex:
            asyncio.get_running_loop().call_exception_handler(
                {
                    &#34;message&#34;: &#34;Exception occurred in raw event dispatch conduit&#34;,
                    &#34;exception&#34;: ex,
                    &#34;task&#34;: asyncio.current_task(),
                }
            )

    async def _invoke_callback(
        self, callback: event_manager_.CallbackT[event_manager_.EventT_inv], event: event_manager_.EventT_inv
    ) -&gt; None:
        try:
            await callback(event)
        except Exception as ex:
            # Skip the first frame in logs, we don&#39;t care for it.
            trio = type(ex), ex, ex.__traceback__.tb_next if ex.__traceback__ is not None else None

            if base_events.is_no_recursive_throw_event(event):
                _LOGGER.error(
                    &#34;an exception occurred handling an event (%s), but it has been ignored&#34;,
                    type(event).__name__,
                    exc_info=trio,
                )
            else:
                exception_event = base_events.ExceptionEvent(
                    exception=ex,
                    failed_event=event,
                    failed_callback=callback,
                )

                log = _LOGGER.debug if self.get_listeners(type(exception_event), polymorphic=True) else _LOGGER.error
                log(&#34;an exception occurred handling an event (%s)&#34;, type(event).__name__, exc_info=trio)
                await self.dispatch(exception_event)</code></pre>
</details>
</div>
</div>
<h2 id="functions-heading">Functions</h2>
<section class="definition">
<dl class="no-nest root">
<div id="hikari.impl.event_manager_base.filtered" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="filtered" href="#hikari.impl.event_manager_base.filtered" id="hikari.impl.event_manager_base.filtered">filtered</a>(
    event_types: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[<a href='../events/base_events.html#hikari.events.base_events.Event'>base_events.Event</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[<a href='../events/base_events.html#hikari.events.base_events.Event'>base_events.Event</a>]]],
    cache_components: <a href='../api/config.html#hikari.api.config.CacheComponents'>config.CacheComponents</a> = &lt;CacheComponents.NONE: 0&gt;,
    /,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[UnboundMethodT[EventManagerBaseT]], UnboundMethodT[EventManagerBaseT]]: ...</code></pre>
</dt>
<dd>
<p>Add metadata to a consumer method to indicate when it should be unmarshalled and dispatched.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event_types</code></strong></dt>
<dd>Types of the events this raw consumer method may dispatch.
This may either be a singular type of a sequence of types.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>cache_components</code></strong> :&ensp;<code><a href='../api/config.html#hikari.api.config.CacheComponents'>CacheComponents</a></code></dt>
<dd>Bitfield of the cache components this event may make altering calls to.
This defaults to <code><a href='../api/config.html#hikari.api.config.CacheComponents.NONE'>NONE</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/6dbab9a6f401bcf597997b46820717e4dd956c13/hikari/impl/event_manager_base.py#L279-L316" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def filtered(
    event_types: typing.Union[typing.Type[base_events.Event], typing.Sequence[typing.Type[base_events.Event]]],
    cache_components: config.CacheComponents = config.CacheComponents.NONE,
    /,
) -&gt; typing.Callable[[UnboundMethodT[EventManagerBaseT]], UnboundMethodT[EventManagerBaseT]]:
    &#34;&#34;&#34;Add metadata to a consumer method to indicate when it should be unmarshalled and dispatched.

    Parameters
    ----------
    event_types
        Types of the events this raw consumer method may dispatch.
        This may either be a singular type of a sequence of types.

    Other Parameters
    ----------------
    cache_components : hikari.api.config.CacheComponents
        Bitfield of the cache components this event may make altering calls to.
        This defaults to `hikari.api.config.CacheComponents.NONE`.
    &#34;&#34;&#34;
    if isinstance(event_types, typing.Sequence):
        # dict.fromkeys is used to remove any duplicate entries here
        event_types = tuple(dict.fromkeys(itertools.chain.from_iterable(e.dispatches() for e in event_types)))

    else:
        event_types = event_types.dispatches()

    bitmask = 0
    for event_type in event_types:
        bitmask |= event_type.bitmask()

    # https://github.com/python/mypy/issues/2087
    def decorator(method: UnboundMethodT[EventManagerBaseT], /) -&gt; UnboundMethodT[EventManagerBaseT]:
        method.__cache_components__ = cache_components  # type: ignore[attr-defined]
        method.__events_bitmask__ = bitmask  # type: ignore[attr-defined]
        assert isinstance(method, _FilteredMethodT), &#34;Incorrect attribute(s) set for a filtered method&#34;
        return method  # type: ignore[unreachable]

    return decorator</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
</dl>
</section>
<h2 id="class-heading">Classes</h2>
<section class="definition">
<dl class="no-nest root">
<div id="hikari.impl.event_manager_base.EventManagerBase" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="EventManagerBase -- Provides functionality to consume and dispatch events …" href="#hikari.impl.event_manager_base.EventManagerBase"
>EventManagerBase</a></h4>
</dt>
<dd>
<pre><code id="hikari.impl.event_manager_base.EventManagerBase" class="hljs python"><abbr title='A standard Python type.'>class</abbr> EventManagerBase (
    event_factory: <a href='../api/event_factory.html#hikari.api.event_factory.EventFactory'>event_factory_.EventFactory</a>,
    intents: <a href='../intents.html#hikari.intents.Intents'>intents_.Intents</a>,
    *,
    cache_components: <a href='../api/config.html#hikari.api.config.CacheComponents'>config.CacheComponents</a> = &lt;CacheComponents.NONE: 0&gt;,
): ...</code></pre>
<p>Provides functionality to consume and dispatch events.</p>
<p>Specific event handlers should be in functions named <code>on_xxx</code> where <code>xxx</code>
is the raw event name being dispatched in lower-case.</p>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/6dbab9a6f401bcf597997b46820717e4dd956c13/hikari/impl/event_manager_base.py#L341-L660" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class EventManagerBase(event_manager_.EventManager):
    &#34;&#34;&#34;Provides functionality to consume and dispatch events.

    Specific event handlers should be in functions named `on_xxx` where `xxx`
    is the raw event name being dispatched in lower-case.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (
        &#34;_consumers&#34;,
        &#34;_event_factory&#34;,
        &#34;_intents&#34;,
        &#34;_listeners&#34;,
        &#34;_waiters&#34;,
    )

    def __init__(
        self,
        event_factory: event_factory_.EventFactory,
        intents: intents_.Intents,
        *,
        cache_components: config.CacheComponents = config.CacheComponents.NONE,
    ) -&gt; None:
        self._consumers: typing.Dict[str, _Consumer] = {}
        self._event_factory = event_factory
        self._intents = intents
        self._listeners: ListenerMapT[base_events.Event] = {}
        self._waiters: WaiterMapT[base_events.Event] = {}

        for name, member in inspect.getmembers(self):
            if name.startswith(&#34;on_&#34;):
                event_name = name[3:]
                if isinstance(member, _FilteredMethodT):
                    caching = (member.__cache_components__ &amp; cache_components) != 0

                    self._consumers[event_name] = _Consumer(member, member.__events_bitmask__, caching)

                else:
                    self._consumers[event_name] = _Consumer(member, -1, cache_components != cache_components.NONE)

    def _increment_listener_group_count(
        self, event_type: typing.Type[base_events.Event], count: typing.Literal[-1, 1]
    ) -&gt; None:
        event_bitmask = event_type.bitmask()
        for consumer in self._consumers.values():
            if (consumer.events_bitmask &amp; event_bitmask) == event_bitmask:
                consumer.listener_group_count += count

    def _increment_waiter_group_count(
        self, event_type: typing.Type[base_events.Event], count: typing.Literal[-1, 1]
    ) -&gt; None:
        event_bitmask = event_type.bitmask()
        for consumer in self._consumers.values():
            if (consumer.events_bitmask &amp; event_bitmask) == event_bitmask:
                consumer.waiter_group_count += count

    def _enabled_for_event(self, event_type: typing.Type[base_events.Event], /) -&gt; bool:
        for cls in event_type.dispatches():
            if cls in self._listeners or cls in self._waiters:
                return True

        return False

    def consume_raw_event(
        self, event_name: str, shard: gateway_shard.GatewayShard, payload: data_binding.JSONObject
    ) -&gt; None:
        if self._enabled_for_event(shard_events.ShardPayloadEvent):
            payload_event = self._event_factory.deserialize_shard_payload_event(shard, payload, name=event_name)
            self.dispatch(payload_event)
        consumer = self._consumers[event_name.lower()]
        asyncio.create_task(self._handle_dispatch(consumer, shard, payload), name=f&#34;dispatch {event_name}&#34;)

    def subscribe(
        self,
        event_type: typing.Type[event_manager_.EventT_co],
        callback: event_manager_.CallbackT[event_manager_.EventT_co],
        *,
        _nested: int = 0,
    ) -&gt; None:
        if not inspect.isclass(event_type) or not issubclass(event_type, base_events.Event):
            raise TypeError(&#34;Cannot subscribe to a non-Event type&#34;)

        if not inspect.iscoroutinefunction(callback):
            raise TypeError(&#34;Cannot subscribe a non-coroutine function callback&#34;)

        # `_nested` is used to show the correct source code snippet if an intent
        # warning is triggered.
        self._check_intents(event_type, _nested)

        _LOGGER.debug(
            &#34;subscribing callback &#39;async def %s%s&#39; to event-type %s.%s&#34;,
            getattr(callback, &#34;__name__&#34;, &#34;&lt;anon&gt;&#34;),
            inspect.signature(callback),
            event_type.__module__,
            event_type.__qualname__,
        )

        try:
            self._listeners[event_type].append(callback)  # type: ignore[arg-type]
        except KeyError:
            self._listeners[event_type] = [callback]  # type: ignore[list-item]
            self._increment_listener_group_count(event_type, 1)

    def _check_intents(self, event_type: typing.Type[event_manager_.EventT_co], nested: int) -&gt; None:
        # Collection of combined bitfield combinations of intents that
        # could be enabled to receive this event.
        expected_intent_groups = base_events.get_required_intents_for(event_type)

        if expected_intent_groups:
            for expected_intent_group in expected_intent_groups:
                if (self._intents &amp; expected_intent_group) == expected_intent_group:
                    break
            else:
                expected_intents_str = &#34;, &#34;.join(map(str, expected_intent_groups))

                warnings.warn(
                    f&#34;You have tried to listen to {event_type.__name__}, but this will only ever be triggered if &#34;
                    f&#34;you enable one of the following intents: {expected_intents_str}.&#34;,
                    category=errors.MissingIntentWarning,
                    stacklevel=nested + 3,
                )

    def get_listeners(
        self,
        event_type: typing.Type[event_manager_.EventT_co],
        /,
        *,
        polymorphic: bool = True,
    ) -&gt; typing.Collection[event_manager_.CallbackT[event_manager_.EventT_co]]:
        if polymorphic:
            listeners: typing.List[event_manager_.CallbackT[event_manager_.EventT_co]] = []
            for event in event_type.dispatches():
                if subscribed_listeners := self._listeners.get(event):
                    listeners.extend(subscribed_listeners)

            return listeners

        if items := self._listeners.get(event_type):
            return items.copy()

        return []

    def unsubscribe(
        self,
        event_type: typing.Type[event_manager_.EventT_co],
        callback: event_manager_.CallbackT[event_manager_.EventT_co],
    ) -&gt; None:
        if listeners := self._listeners.get(event_type):
            _LOGGER.debug(
                &#34;unsubscribing callback %s%s from event-type %s.%s&#34;,
                getattr(callback, &#34;__name__&#34;, &#34;&lt;anon&gt;&#34;),
                inspect.signature(callback),
                event_type.__module__,
                event_type.__qualname__,
            )
            listeners.remove(callback)  # type: ignore[arg-type]
            if not listeners:
                del self._listeners[event_type]
                self._increment_listener_group_count(event_type, -1)

    def listen(
        self,
        event_type: typing.Optional[typing.Type[event_manager_.EventT_co]] = None,
    ) -&gt; typing.Callable[
        [event_manager_.CallbackT[event_manager_.EventT_co]], event_manager_.CallbackT[event_manager_.EventT_co]
    ]:
        def decorator(
            callback: event_manager_.CallbackT[event_manager_.EventT_co],
        ) -&gt; event_manager_.CallbackT[event_manager_.EventT_co]:
            nonlocal event_type

            # Avoid resolving forward references in the function&#39;s signature if
            # event_type was explicitly provided as this may lead to errors.
            if event_type is not None:
                _assert_is_listener(iter(inspect.signature(callback).parameters.values()))

            else:
                signature = reflect.resolve_signature(callback)
                params = signature.parameters.values()
                _assert_is_listener(iter(params))
                event_param = next(iter(params))

                if event_param.annotation is event_param.empty:
                    raise TypeError(&#34;Must provide the event type in the @listen decorator or as a type hint!&#34;)

                event_type = event_param.annotation

            self.subscribe(event_type, callback, _nested=1)
            return callback

        return decorator

    def dispatch(self, event: event_manager_.EventT_inv) -&gt; asyncio.Future[typing.Any]:
        if not isinstance(event, base_events.Event):
            raise TypeError(f&#34;Events must be subclasses of {base_events.Event.__name__}, not {type(event).__name__}&#34;)

        tasks: typing.List[typing.Coroutine[None, typing.Any, None]] = []

        for cls in event.dispatches():
            if listeners := self._listeners.get(cls):
                for callback in listeners:
                    tasks.append(self._invoke_callback(callback, event))

            if cls not in self._waiters:
                continue

            waiter_set = self._waiters[cls]
            for waiter in tuple(waiter_set):
                predicate, future = waiter
                if not future.done():
                    try:
                        if predicate and not predicate(event):
                            continue
                    except Exception as ex:
                        future.set_exception(ex)
                    else:
                        future.set_result(event)

                waiter_set.remove(waiter)

            if not waiter_set:
                del self._waiters[cls]
                self._increment_waiter_group_count(cls, -1)

        return asyncio.gather(*tasks) if tasks else aio.completed_future()

    def stream(
        self,
        event_type: typing.Type[event_manager_.EventT_co],
        /,
        timeout: typing.Union[float, int, None],
        limit: typing.Optional[int] = None,
    ) -&gt; event_manager_.EventStream[event_manager_.EventT_co]:
        self._check_intents(event_type, 1)
        return EventStream(self, event_type, timeout=timeout, limit=limit)

    async def wait_for(
        self,
        event_type: typing.Type[event_manager_.EventT_co],
        /,
        timeout: typing.Union[float, int, None],
        predicate: typing.Optional[event_manager_.PredicateT[event_manager_.EventT_co]] = None,
    ) -&gt; event_manager_.EventT_co:
        self._check_intents(event_type, 1)

        future: asyncio.Future[event_manager_.EventT_co] = asyncio.get_running_loop().create_future()

        try:
            waiter_set = self._waiters[event_type]
        except KeyError:
            waiter_set = set()
            self._waiters[event_type] = waiter_set
            self._increment_waiter_group_count(event_type, 1)

        pair = (predicate, future)

        waiter_set.add(pair)  # type: ignore[arg-type]
        try:
            return await asyncio.wait_for(future, timeout=timeout)
        except asyncio.TimeoutError:
            waiter_set.remove(pair)  # type: ignore[arg-type]
            if not waiter_set:
                del self._waiters[event_type]
                self._increment_waiter_group_count(event_type, -1)

            raise

    async def _handle_dispatch(
        self,
        consumer: _Consumer,
        shard: gateway_shard.GatewayShard,
        payload: data_binding.JSONObject,
    ) -&gt; None:
        if not consumer.is_enabled:
            name = consumer.callback.__name__
            _LOGGER.log(
                ux.TRACE, &#34;Skipping raw dispatch for %s due to lack of any registered listeners or cache need&#34;, name
            )
            return

        try:
            await consumer.callback(shard, payload)
        except asyncio.CancelledError:
            # Skip cancelled errors, likely caused by the event loop being shut down.
            pass
        except errors.UnrecognisedEntityError:
            _LOGGER.debug(&#34;Event referenced an unrecognised entity, discarding&#34;)
        except BaseException as ex:
            asyncio.get_running_loop().call_exception_handler(
                {
                    &#34;message&#34;: &#34;Exception occurred in raw event dispatch conduit&#34;,
                    &#34;exception&#34;: ex,
                    &#34;task&#34;: asyncio.current_task(),
                }
            )

    async def _invoke_callback(
        self, callback: event_manager_.CallbackT[event_manager_.EventT_inv], event: event_manager_.EventT_inv
    ) -&gt; None:
        try:
            await callback(event)
        except Exception as ex:
            # Skip the first frame in logs, we don&#39;t care for it.
            trio = type(ex), ex, ex.__traceback__.tb_next if ex.__traceback__ is not None else None

            if base_events.is_no_recursive_throw_event(event):
                _LOGGER.error(
                    &#34;an exception occurred handling an event (%s), but it has been ignored&#34;,
                    type(event).__name__,
                    exc_info=trio,
                )
            else:
                exception_event = base_events.ExceptionEvent(
                    exception=ex,
                    failed_event=event,
                    failed_callback=callback,
                )

                log = _LOGGER.debug if self.get_listeners(type(exception_event), polymorphic=True) else _LOGGER.error
                log(&#34;an exception occurred handling an event (%s)&#34;, type(event).__name__, exc_info=trio)
                await self.dispatch(exception_event)</code></pre>
</details>
<div class="sep"></div>
<h5>Subclasses</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="EventManagerImpl -- Provides event handling logic for Discord events." href="event_manager.html#hikari.impl.event_manager.EventManagerImpl"
>EventManagerImpl</a></dt>
<dd class="nested"><p>Provides event handling logic for Discord events.</p></dd>
</dl>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="EventManagerBase -- Provides functionality to consume and dispatch events …" href="#hikari.impl.event_manager_base.EventManagerBase"
>EventManagerBase</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="EventManager -- Base interface for event manager implementations …" href="../api/event_manager.html#hikari.api.event_manager.EventManager"
>EventManager</a></dt>
<dd class="nested"><p>Base interface for event manager implementations …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<div id="hikari.impl.event_manager_base.EventManagerBase.consume_raw_event" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="consume_raw_event" href="#hikari.impl.event_manager_base.EventManagerBase.consume_raw_event" id="hikari.impl.event_manager_base.EventManagerBase.consume_raw_event">consume_raw_event</a>(
    event_name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    shard: <a href='../api/shard.html#hikari.api.shard.GatewayShard'>gateway_shard.GatewayShard</a>,
    payload: <a href='../internal/data_binding.html#hikari.internal.data_binding.JSONObject'>data_binding.JSONObject</a>,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="EventManager -- Base interface for event manager implementations …" href="../api/event_manager.html#hikari.api.event_manager.EventManager"
>EventManager</a></code>.<code><a title="consume_raw_event -- Consume a raw event …" href="../api/event_manager.html#hikari.api.event_manager.EventManager.consume_raw_event"
>consume_raw_event</a></code>
</p>
<p>Consume a raw event.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event_name</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The case-insensitive name of the event being triggered.</dd>
<dt><strong><code>shard</code></strong> :&ensp;<code><a href='../api/shard.html#hikari.api.shard.GatewayShard'>GatewayShard</a></code></dt>
<dd>Object of the shard that received this event.</dd>
<dt><strong><code>payload</code></strong> :&ensp;<code><a href='../internal/data_binding.html#hikari.internal.data_binding.JSONObject'>JSONObject</a></code></dt>
<dd>Payload of the event being triggered.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#LookupError'>LookupError</a></code></dt>
<dd>If there is no consumer for the event.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/6dbab9a6f401bcf597997b46820717e4dd956c13/hikari/impl/event_manager_base.py#L403-L410" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def consume_raw_event(
    self, event_name: str, shard: gateway_shard.GatewayShard, payload: data_binding.JSONObject
) -&gt; None:
    if self._enabled_for_event(shard_events.ShardPayloadEvent):
        payload_event = self._event_factory.deserialize_shard_payload_event(shard, payload, name=event_name)
        self.dispatch(payload_event)
    consumer = self._consumers[event_name.lower()]
    asyncio.create_task(self._handle_dispatch(consumer, shard, payload), name=f&#34;dispatch {event_name}&#34;)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.event_manager_base.EventManagerBase.dispatch" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="dispatch" href="#hikari.impl.event_manager_base.EventManagerBase.dispatch" id="hikari.impl.event_manager_base.EventManagerBase.dispatch">dispatch</a>(
    event: event_manager_.EventT_inv,
) -> <a href='https://docs.python.org/3/library/asyncio-future.html#asyncio.Future'>Future</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="EventManager -- Base interface for event manager implementations …" href="../api/event_manager.html#hikari.api.event_manager.EventManager"
>EventManager</a></code>.<code><a title="dispatch -- Dispatch an event …" href="../api/event_manager.html#hikari.api.event_manager.EventManager.dispatch"
>dispatch</a></code>
</p>
<p>Dispatch an event.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code><a href='../events/base_events.html#hikari.events.base_events.Event'>Event</a></code></dt>
<dd>The event to dispatch.</dd>
</dl>
<h2 id="example">Example</h2>
<p>We can dispatch custom events by first defining a class that
derives from <code><a href='../events/base_events.html#hikari.events.base_events.Event'>Event</a></code>.</p>
<pre><code class="language-py">import attr

from hikari.traits import RESTAware
from hikari.events.base_events import Event
from hikari.users import User
from hikari.snowflakes import Snowflake

@attr.define()
class EveryoneMentionedEvent(Event):
    app: RESTAware = attr.field()

    author: User = attr.field()
    '''The user who mentioned everyone.'''

    content: str = attr.field()
    '''The message that was sent.'''

    message_id: Snowflake = attr.field()
    '''The message ID.'''

    channel_id: Snowflake = attr.field()
    '''The channel ID.'''
</code></pre>
<p>We can then dispatch our event as we see fit.</p>
<pre><code class="language-py">from hikari.events.messages import MessageCreateEvent

@bot.listen(MessageCreateEvent)
async def on_message(event):
    if &quot;@everyone&quot; in event.content or &quot;@here&quot; in event.content:
        event = EveryoneMentionedEvent(
            author=event.author,
            content=event.content,
            message_id=event.id,
            channel_id=event.channel_id,
        )

        bot.dispatch(event)
</code></pre>
<p>This event can be listened to elsewhere by subscribing to it with
<code>EventManager.subscribe</code>.</p>
<pre><code class="language-py">@bot.listen(EveryoneMentionedEvent)
async def on_everyone_mentioned(event):
    print(event.user, &quot;just pinged everyone in&quot;, event.channel_id)
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/asyncio-future.html#asyncio.Future'>Future</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]</code></dt>
<dd>A future that can be optionally awaited. If awaited, the future
will complete once all corresponding event listeners have been
invoked. If not awaited, this will schedule the dispatch of the
events in the background for later.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>Listen</code></dt>
<dd><code><a href='../api/event_manager.html#hikari.api.event_manager.EventManager.listen'>listen</a></code></dd>
<dt><code>Stream</code></dt>
<dd><code><a href='../api/event_manager.html#hikari.api.event_manager.EventManager.stream'>stream</a></code></dd>
<dt><code>Subscribe</code></dt>
<dd><code><a href='../api/event_manager.html#hikari.api.event_manager.EventManager.subscribe'>subscribe</a></code></dd>
<dt><code>Unsubscribe</code></dt>
<dd><code><a href='../api/event_manager.html#hikari.api.event_manager.EventManager.unsubscribe'>unsubscribe</a></code></dd>
<dt><code>Wait_for</code></dt>
<dd><code><a href='../api/event_manager.html#hikari.api.event_manager.EventManager.wait_for'>wait_for</a></code></dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/6dbab9a6f401bcf597997b46820717e4dd956c13/hikari/impl/event_manager_base.py#L532-L564" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def dispatch(self, event: event_manager_.EventT_inv) -&gt; asyncio.Future[typing.Any]:
    if not isinstance(event, base_events.Event):
        raise TypeError(f&#34;Events must be subclasses of {base_events.Event.__name__}, not {type(event).__name__}&#34;)

    tasks: typing.List[typing.Coroutine[None, typing.Any, None]] = []

    for cls in event.dispatches():
        if listeners := self._listeners.get(cls):
            for callback in listeners:
                tasks.append(self._invoke_callback(callback, event))

        if cls not in self._waiters:
            continue

        waiter_set = self._waiters[cls]
        for waiter in tuple(waiter_set):
            predicate, future = waiter
            if not future.done():
                try:
                    if predicate and not predicate(event):
                        continue
                except Exception as ex:
                    future.set_exception(ex)
                else:
                    future.set_result(event)

            waiter_set.remove(waiter)

        if not waiter_set:
            del self._waiters[cls]
            self._increment_waiter_group_count(cls, -1)

    return asyncio.gather(*tasks) if tasks else aio.completed_future()</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.event_manager_base.EventManagerBase.get_listeners" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_listeners" href="#hikari.impl.event_manager_base.EventManagerBase.get_listeners" id="hikari.impl.event_manager_base.EventManagerBase.get_listeners">get_listeners</a>(
    event_type: <a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[event_manager_.EventT_co],
    /,
    *,
    polymorphic: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a> = True,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[event_manager_.CallbackT[event_manager_.EventT_co]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="EventManager -- Base interface for event manager implementations …" href="../api/event_manager.html#hikari.api.event_manager.EventManager"
>EventManager</a></code>.<code><a title="get_listeners -- Get the listeners for a given event type, if there are any …" href="../api/event_manager.html#hikari.api.event_manager.EventManager.get_listeners"
>get_listeners</a></code>
</p>
<p>Get the listeners for a given event type, if there are any.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event_type</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[T]</code></dt>
<dd>The event type to look for.
<code>T</code> must be a subclass of <code><a href='../events/base_events.html#hikari.events.base_events.Event'>Event</a></code>.</dd>
<dt><strong><code>polymorphic</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></dt>
<dd>If <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, this will also return the listeners for all the
event types <code>event_type</code> will dispatch. If <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, then
only listeners for this class specifically are returned. The
default is <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[T], <a href='https://docs.python.org/3/library/typing.html#typing.Coroutine'>Coroutine</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>, <a href='https://docs.python.org/3/library/constants.html#None'>None</a>]]</code></dt>
<dd>
<p>A copy of the collection of listeners for the event. Will return
an empty collection if nothing is registered.</p>
<p><code>T</code> must be a subclass of <code><a href='../events/base_events.html#hikari.events.base_events.Event'>Event</a></code>.</p>
</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code>Has listener: </code>hikari.api.event_manager.EventManager.has_listener``</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/6dbab9a6f401bcf597997b46820717e4dd956c13/hikari/impl/event_manager_base.py#L462-L480" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_listeners(
    self,
    event_type: typing.Type[event_manager_.EventT_co],
    /,
    *,
    polymorphic: bool = True,
) -&gt; typing.Collection[event_manager_.CallbackT[event_manager_.EventT_co]]:
    if polymorphic:
        listeners: typing.List[event_manager_.CallbackT[event_manager_.EventT_co]] = []
        for event in event_type.dispatches():
            if subscribed_listeners := self._listeners.get(event):
                listeners.extend(subscribed_listeners)

        return listeners

    if items := self._listeners.get(event_type):
        return items.copy()

    return []</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.event_manager_base.EventManagerBase.listen" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="listen" href="#hikari.impl.event_manager_base.EventManagerBase.listen" id="hikari.impl.event_manager_base.EventManagerBase.listen">listen</a>(
    event_type: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[event_manager_.EventT_co]] = None,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[event_manager_.CallbackT[event_manager_.EventT_co]], event_manager_.CallbackT[event_manager_.EventT_co]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="EventManager -- Base interface for event manager implementations …" href="../api/event_manager.html#hikari.api.event_manager.EventManager"
>EventManager</a></code>.<code><a title="listen -- Generate a decorator to subscribe a callback to an event type …" href="../api/event_manager.html#hikari.api.event_manager.EventManager.listen"
>listen</a></code>
</p>
<p>Generate a decorator to subscribe a callback to an event type.</p>
<p>This is a second-order decorator.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event_type</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[T]]</code></dt>
<dd>
<p>The event type to subscribe to. The implementation may allow this
to be undefined. If this is the case, the event type will be inferred
instead from the type hints on the function signature.</p>
<p><code>T</code> must be a subclass of <code><a href='../events/base_events.html#hikari.events.base_events.Event'>Event</a></code>.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[T], T]</code></dt>
<dd>A decorator for a coroutine function that passes it to
<code>EventManager.subscribe</code> before returning the function
reference.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>Dispatch</code></dt>
<dd><code><a href='../api/event_manager.html#hikari.api.event_manager.EventManager.dispatch'>dispatch</a></code></dd>
<dt><code>Stream</code></dt>
<dd><code><a href='../api/event_manager.html#hikari.api.event_manager.EventManager.stream'>stream</a></code></dd>
<dt><code>Subscribe</code></dt>
<dd><code><a href='../api/event_manager.html#hikari.api.event_manager.EventManager.subscribe'>subscribe</a></code></dd>
<dt><code>Unsubscribe</code></dt>
<dd><code><a href='../api/event_manager.html#hikari.api.event_manager.EventManager.unsubscribe'>unsubscribe</a></code></dd>
<dt><code>Wait_for</code></dt>
<dd><code><a href='../api/event_manager.html#hikari.api.event_manager.EventManager.wait_for'>wait_for</a></code></dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/6dbab9a6f401bcf597997b46820717e4dd956c13/hikari/impl/event_manager_base.py#L500-L530" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def listen(
    self,
    event_type: typing.Optional[typing.Type[event_manager_.EventT_co]] = None,
) -&gt; typing.Callable[
    [event_manager_.CallbackT[event_manager_.EventT_co]], event_manager_.CallbackT[event_manager_.EventT_co]
]:
    def decorator(
        callback: event_manager_.CallbackT[event_manager_.EventT_co],
    ) -&gt; event_manager_.CallbackT[event_manager_.EventT_co]:
        nonlocal event_type

        # Avoid resolving forward references in the function&#39;s signature if
        # event_type was explicitly provided as this may lead to errors.
        if event_type is not None:
            _assert_is_listener(iter(inspect.signature(callback).parameters.values()))

        else:
            signature = reflect.resolve_signature(callback)
            params = signature.parameters.values()
            _assert_is_listener(iter(params))
            event_param = next(iter(params))

            if event_param.annotation is event_param.empty:
                raise TypeError(&#34;Must provide the event type in the @listen decorator or as a type hint!&#34;)

            event_type = event_param.annotation

        self.subscribe(event_type, callback, _nested=1)
        return callback

    return decorator</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.event_manager_base.EventManagerBase.stream" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="stream" href="#hikari.impl.event_manager_base.EventManagerBase.stream" id="hikari.impl.event_manager_base.EventManagerBase.stream">stream</a>(
    event_type: <a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[event_manager_.EventT_co],
    /,
    timeout: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/functions.html#float'>float</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>, <a href='https://docs.python.org/3/library/constants.html#None'>None</a>],
    limit: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = None,
) -> <a href='../api/event_manager.html#hikari.api.event_manager.EventStream'>event_manager_.EventStream</a>[event_manager_.EventT_co]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="EventManager -- Base interface for event manager implementations …" href="../api/event_manager.html#hikari.api.event_manager.EventManager"
>EventManager</a></code>.<code><a title="stream -- Return a stream iterator for the given event and sub-events …" href="../api/event_manager.html#hikari.api.event_manager.EventManager.stream"
>stream</a></code>
</p>
<p>Return a stream iterator for the given event and sub-events.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event_type</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[<a href='../events/base_events.html#hikari.events.base_events.Event'>Event</a>]</code></dt>
<dd>The event type to listen for. This will listen for subclasses of
this type additionally.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>, <a href='https://docs.python.org/3/library/functions.html#float'>float</a>]</code></dt>
<dd>How long this streamer should wait for the next event before
ending the iteration. If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> then this will continue
until explicitly broken from.</dd>
<dt><strong><code>limit</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>The limit for how many events this should queue at one time before
dropping extra incoming events, leave this as <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> for
the cache size to be unlimited.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.impl.event_manager_base.EventStream'>EventStream</a>[<a href='../events/base_events.html#hikari.events.base_events.Event'>Event</a>]</code></dt>
<dd>The async iterator to handle streamed events. This must be started
with <code><a href='https://docs.python.org/3/reference/compound_stmts.html#with'>with</a> stream:</code> or <code>stream.open()</code> before
asynchronously iterating over it.</dd>
</dl>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>If you use <code>stream.open()</code> to start the stream then you must
also close it with <code>stream.close()</code> otherwise it may queue
events in memory indefinitely.</p>
</div>
<h2 id="examples">Examples</h2>
<pre><code class="language-py">with bot.stream(events.ReactionAddEvent, timeout=30).filter((&quot;message_id&quot;, message.id)) as stream:
    async for user_id in stream.map(&quot;user_id&quot;).limit(50):
        ...
</code></pre>
<p>or using <code><a href='https://docs.python.org/3/library/functions.html#open'>open</a>()</code> and <code>close()</code></p>
<pre><code class="language-py">stream = bot.stream(events.ReactionAddEvent, timeout=30).filter((&quot;message_id&quot;, message.id))
stream.open()

async for user_id in stream.map(&quot;user_id&quot;).limit(50)
    ...

stream.close()
</code></pre>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>Dispatch</code></dt>
<dd><code><a href='../api/event_manager.html#hikari.api.event_manager.EventManager.dispatch'>dispatch</a></code></dd>
<dt><code>Listen</code></dt>
<dd><code><a href='../api/event_manager.html#hikari.api.event_manager.EventManager.listen'>listen</a></code></dd>
<dt><code>Subscribe</code></dt>
<dd><code><a href='../api/event_manager.html#hikari.api.event_manager.EventManager.subscribe'>subscribe</a></code></dd>
<dt><code>Unsubscribe</code></dt>
<dd><code><a href='../api/event_manager.html#hikari.api.event_manager.EventManager.unsubscribe'>unsubscribe</a></code></dd>
<dt><code>Wait_for</code></dt>
<dd><code><a href='../api/event_manager.html#hikari.api.event_manager.EventManager.wait_for'>wait_for</a></code></dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/6dbab9a6f401bcf597997b46820717e4dd956c13/hikari/impl/event_manager_base.py#L566-L574" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def stream(
    self,
    event_type: typing.Type[event_manager_.EventT_co],
    /,
    timeout: typing.Union[float, int, None],
    limit: typing.Optional[int] = None,
) -&gt; event_manager_.EventStream[event_manager_.EventT_co]:
    self._check_intents(event_type, 1)
    return EventStream(self, event_type, timeout=timeout, limit=limit)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.event_manager_base.EventManagerBase.subscribe" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="subscribe" href="#hikari.impl.event_manager_base.EventManagerBase.subscribe" id="hikari.impl.event_manager_base.EventManagerBase.subscribe">subscribe</a>(
    event_type: <a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[event_manager_.EventT_co],
    callback: event_manager_.CallbackT[event_manager_.EventT_co],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="EventManager -- Base interface for event manager implementations …" href="../api/event_manager.html#hikari.api.event_manager.EventManager"
>EventManager</a></code>.<code><a title="subscribe -- Subscribe a given callback to a given event type …" href="../api/event_manager.html#hikari.api.event_manager.EventManager.subscribe"
>subscribe</a></code>
</p>
<p>Subscribe a given callback to a given event type.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event_type</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[T]</code></dt>
<dd>The event type to listen for. This will also listen for any
subclasses of the given type.
<code>T</code> must be a subclass of <code><a href='../events/base_events.html#hikari.events.base_events.Event'>Event</a></code>.</dd>
<dt><strong><code>callback</code></strong></dt>
<dd>Must be a coroutine function to invoke. This should
consume an instance of the given event, or an instance of a valid
subclass if one exists. Any result is discarded.</dd>
</dl>
<h2 id="example">Example</h2>
<p>The following demonstrates subscribing a callback to message creation
events.</p>
<pre><code class="language-py">from hikari.events.messages import MessageCreateEvent

async def on_message(event):
    ...

bot.subscribe(MessageCreateEvent, on_message)
</code></pre>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>Dispatch</code></dt>
<dd><code><a href='../api/event_manager.html#hikari.api.event_manager.EventManager.dispatch'>dispatch</a></code></dd>
<dt><code>Listen</code></dt>
<dd><code><a href='../api/event_manager.html#hikari.api.event_manager.EventManager.listen'>listen</a></code></dd>
<dt><code>Stream</code></dt>
<dd><code><a href='../api/event_manager.html#hikari.api.event_manager.EventManager.stream'>stream</a></code></dd>
<dt><code>Unsubscribe</code></dt>
<dd><code><a href='../api/event_manager.html#hikari.api.event_manager.EventManager.unsubscribe'>unsubscribe</a></code></dd>
<dt><code>Wait_for</code></dt>
<dd><code><a href='../api/event_manager.html#hikari.api.event_manager.EventManager.wait_for'>wait_for</a></code></dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/6dbab9a6f401bcf597997b46820717e4dd956c13/hikari/impl/event_manager_base.py#L412-L441" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def subscribe(
    self,
    event_type: typing.Type[event_manager_.EventT_co],
    callback: event_manager_.CallbackT[event_manager_.EventT_co],
    *,
    _nested: int = 0,
) -&gt; None:
    if not inspect.isclass(event_type) or not issubclass(event_type, base_events.Event):
        raise TypeError(&#34;Cannot subscribe to a non-Event type&#34;)

    if not inspect.iscoroutinefunction(callback):
        raise TypeError(&#34;Cannot subscribe a non-coroutine function callback&#34;)

    # `_nested` is used to show the correct source code snippet if an intent
    # warning is triggered.
    self._check_intents(event_type, _nested)

    _LOGGER.debug(
        &#34;subscribing callback &#39;async def %s%s&#39; to event-type %s.%s&#34;,
        getattr(callback, &#34;__name__&#34;, &#34;&lt;anon&gt;&#34;),
        inspect.signature(callback),
        event_type.__module__,
        event_type.__qualname__,
    )

    try:
        self._listeners[event_type].append(callback)  # type: ignore[arg-type]
    except KeyError:
        self._listeners[event_type] = [callback]  # type: ignore[list-item]
        self._increment_listener_group_count(event_type, 1)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.event_manager_base.EventManagerBase.unsubscribe" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="unsubscribe" href="#hikari.impl.event_manager_base.EventManagerBase.unsubscribe" id="hikari.impl.event_manager_base.EventManagerBase.unsubscribe">unsubscribe</a>(
    event_type: <a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[event_manager_.EventT_co],
    callback: event_manager_.CallbackT[event_manager_.EventT_co],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="EventManager -- Base interface for event manager implementations …" href="../api/event_manager.html#hikari.api.event_manager.EventManager"
>EventManager</a></code>.<code><a title="unsubscribe -- Unsubscribe a given callback from a given event type, if present …" href="../api/event_manager.html#hikari.api.event_manager.EventManager.unsubscribe"
>unsubscribe</a></code>
</p>
<p>Unsubscribe a given callback from a given event type, if present.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event_type</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[T]</code></dt>
<dd>The event type to unsubscribe from. This must be the same exact
type as was originally subscribed with to be removed correctly.
<code>T</code> must derive from <code><a href='../events/base_events.html#hikari.events.base_events.Event'>Event</a></code>.</dd>
<dt><strong><code>callback</code></strong></dt>
<dd>The callback to unsubscribe.</dd>
</dl>
<h2 id="example">Example</h2>
<p>The following demonstrates unsubscribing a callback from a message
creation event.</p>
<pre><code class="language-py">from hikari.events.messages import MessageCreateEvent

async def on_message(event):
    ...

bot.unsubscribe(MessageCreateEvent, on_message)
</code></pre>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>Dispatch</code></dt>
<dd><code><a href='../api/event_manager.html#hikari.api.event_manager.EventManager.dispatch'>dispatch</a></code></dd>
<dt><code>Listen</code></dt>
<dd><code><a href='../api/event_manager.html#hikari.api.event_manager.EventManager.listen'>listen</a></code></dd>
<dt><code>Stream</code></dt>
<dd><code><a href='../api/event_manager.html#hikari.api.event_manager.EventManager.stream'>stream</a></code></dd>
<dt><code>Subscribe</code></dt>
<dd><code><a href='../api/event_manager.html#hikari.api.event_manager.EventManager.subscribe'>subscribe</a></code></dd>
<dt><code>Wait_for</code></dt>
<dd><code><a href='../api/event_manager.html#hikari.api.event_manager.EventManager.wait_for'>wait_for</a></code></dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/6dbab9a6f401bcf597997b46820717e4dd956c13/hikari/impl/event_manager_base.py#L482-L498" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def unsubscribe(
    self,
    event_type: typing.Type[event_manager_.EventT_co],
    callback: event_manager_.CallbackT[event_manager_.EventT_co],
) -&gt; None:
    if listeners := self._listeners.get(event_type):
        _LOGGER.debug(
            &#34;unsubscribing callback %s%s from event-type %s.%s&#34;,
            getattr(callback, &#34;__name__&#34;, &#34;&lt;anon&gt;&#34;),
            inspect.signature(callback),
            event_type.__module__,
            event_type.__qualname__,
        )
        listeners.remove(callback)  # type: ignore[arg-type]
        if not listeners:
            del self._listeners[event_type]
            self._increment_listener_group_count(event_type, -1)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.event_manager_base.EventManagerBase.wait_for" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="wait_for" href="#hikari.impl.event_manager_base.EventManagerBase.wait_for" id="hikari.impl.event_manager_base.EventManagerBase.wait_for">wait_for</a>(
    event_type: <a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[event_manager_.EventT_co],
    /,
    timeout: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/functions.html#float'>float</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>, <a href='https://docs.python.org/3/library/constants.html#None'>None</a>],
    predicate: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[event_manager_.PredicateT[event_manager_.EventT_co]] = None,
) -> event_manager_.EventT_co: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="EventManager -- Base interface for event manager implementations …" href="../api/event_manager.html#hikari.api.event_manager.EventManager"
>EventManager</a></code>.<code><a title="wait_for -- Wait for a given event to occur once, then return the event …" href="../api/event_manager.html#hikari.api.event_manager.EventManager.wait_for"
>wait_for</a></code>
</p>
<p>Wait for a given event to occur once, then return the event.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event_type</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[<a href='../events/base_events.html#hikari.events.base_events.Event'>Event</a>]</code></dt>
<dd>The event type to listen for. This will listen for subclasses of
this type additionally.</dd>
<dt><strong><code>predicate</code></strong></dt>
<dd>
<p>A function taking the event as the single parameter.
This should return <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> if the event is one you want to
return, or <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code> if the event should not be returned.
If left as <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> (the default), then the first matching event type
that the bot receives (or any subtype) will be the one returned.</p>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>Async predicates are not supported.</p>
</div>
</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/functions.html#float'>float</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>, <a href='https://docs.python.org/3/library/constants.html#None'>None</a>]</code></dt>
<dd>The amount of time to wait before raising an <code><a href='https://docs.python.org/3/library/asyncio-exceptions.html#asyncio.TimeoutError'>TimeoutError</a></code>
and giving up instead. This is measured in seconds. If
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, then no timeout will be waited for (no timeout can
result in "leaking" of coroutines that never complete if called in
an uncontrolled way, so is not recommended).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../events/base_events.html#hikari.events.base_events.Event'>Event</a></code></dt>
<dd>The event that was provided.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/asyncio-exceptions.html#asyncio.TimeoutError'>TimeoutError</a></code></dt>
<dd>If the timeout is not <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> and is reached before an
event is received that the predicate returns <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> for.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>Dispatch</code></dt>
<dd><code><a href='../api/event_manager.html#hikari.api.event_manager.EventManager.dispatch'>dispatch</a></code></dd>
<dt><code>Listen</code></dt>
<dd><code><a href='../api/event_manager.html#hikari.api.event_manager.EventManager.listen'>listen</a></code></dd>
<dt><code>Stream</code></dt>
<dd><code><a href='../api/event_manager.html#hikari.api.event_manager.EventManager.stream'>stream</a></code></dd>
<dt><code>Subscribe</code></dt>
<dd><code><a href='../api/event_manager.html#hikari.api.event_manager.EventManager.subscribe'>subscribe</a></code></dd>
<dt><code>Unsubscribe</code></dt>
<dd><code><a href='../api/event_manager.html#hikari.api.event_manager.EventManager.unsubscribe'>unsubscribe</a></code></dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/6dbab9a6f401bcf597997b46820717e4dd956c13/hikari/impl/event_manager_base.py#L576-L605" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def wait_for(
    self,
    event_type: typing.Type[event_manager_.EventT_co],
    /,
    timeout: typing.Union[float, int, None],
    predicate: typing.Optional[event_manager_.PredicateT[event_manager_.EventT_co]] = None,
) -&gt; event_manager_.EventT_co:
    self._check_intents(event_type, 1)

    future: asyncio.Future[event_manager_.EventT_co] = asyncio.get_running_loop().create_future()

    try:
        waiter_set = self._waiters[event_type]
    except KeyError:
        waiter_set = set()
        self._waiters[event_type] = waiter_set
        self._increment_waiter_group_count(event_type, 1)

    pair = (predicate, future)

    waiter_set.add(pair)  # type: ignore[arg-type]
    try:
        return await asyncio.wait_for(future, timeout=timeout)
    except asyncio.TimeoutError:
        waiter_set.remove(pair)  # type: ignore[arg-type]
        if not waiter_set:
            del self._waiters[event_type]
            self._increment_waiter_group_count(event_type, -1)

        raise</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</div>
<div id="hikari.impl.event_manager_base.EventStream" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="EventStream -- An implementation of an event `EventStream` class …" href="#hikari.impl.event_manager_base.EventStream"
>EventStream</a></h4>
</dt>
<dd>
<pre><code id="hikari.impl.event_manager_base.EventStream" class="hljs python"><abbr title='A standard Python type.'>class</abbr> EventStream (
    event_manager: <a href='../api/event_manager.html#hikari.api.event_manager.EventManager'>event_manager_.EventManager</a>,
    event_type: <a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[event_manager_.EventT],
    *,
    timeout: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/functions.html#float'>float</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>, <a href='https://docs.python.org/3/library/constants.html#None'>None</a>],
    limit: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = None,
): ...</code></pre>
<p>An implementation of an event <code><a href='#hikari.impl.event_manager_base.EventStream'>EventStream</a></code> class.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>While calling <code><a href='#hikari.impl.event_manager_base.EventStream.filter'>filter</a></code> on an active "opened" event stream
will return a wrapping lazy iterator, calling it on an inactive "closed"
event stream will return the event stream and add the given predicates
to the streamer.</p>
</div>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/6dbab9a6f401bcf597997b46820717e4dd956c13/hikari/impl/event_manager_base.py#L111-L268" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class EventStream(event_manager_.EventStream[event_manager_.EventT]):
    &#34;&#34;&#34;An implementation of an event `EventStream` class.

    !!! note
        While calling `EventStream.filter` on an active &#34;opened&#34; event stream
        will return a wrapping lazy iterator, calling it on an inactive &#34;closed&#34;
        event stream will return the event stream and add the given predicates
        to the streamer.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (
        &#34;__weakref__&#34;,
        &#34;_active&#34;,
        &#34;_event&#34;,
        &#34;_event_manager&#34;,
        &#34;_event_type&#34;,
        &#34;_filters&#34;,
        &#34;_limit&#34;,
        &#34;_queue&#34;,
        &#34;_registered_listener&#34;,
        &#34;_timeout&#34;,
    )

    __weakref__: typing.Optional[weakref.ref[EventStream[event_manager_.EventT]]]

    def __init__(
        self,
        event_manager: event_manager_.EventManager,
        event_type: typing.Type[event_manager_.EventT],
        *,
        timeout: typing.Union[float, int, None],
        limit: typing.Optional[int] = None,
    ) -&gt; None:
        self._active = False
        self._event: typing.Optional[asyncio.Event] = None
        self._event_manager = event_manager
        self._event_type = event_type
        self._filters: iterators.All[event_manager_.EventT] = iterators.All(())
        self._limit = limit
        self._queue: typing.List[event_manager_.EventT] = []
        self._registered_listener: typing.Optional[
            typing.Callable[[event_manager_.EventT], typing.Coroutine[typing.Any, typing.Any, None]]
        ] = None
        # The registered wrapping function for the weak ref to this class&#39;s _listener method.
        self._timeout = timeout

    # These are only included at runtime in-order to avoid the model being typed as an asynchronous context manager.
    if not typing.TYPE_CHECKING:

        async def __aenter__(self: _EventStreamT) -&gt; _EventStreamT:
            # This is sync only.
            warnings.warn(
                &#34;Using EventStream as an async context manager has been deprecated since 2.0.0.dev104. &#34;
                &#34;Please use it as a synchronous context manager (e.g. with bot.stream(...)) instead.&#34;,
                category=DeprecationWarning,
                stacklevel=2,
            )

            self.open()
            return self

        async def __aexit__(
            self,
            exc_type: typing.Optional[typing.Type[BaseException]],
            exc: typing.Optional[BaseException],
            exc_tb: typing.Optional[types.TracebackType],
        ) -&gt; None:
            self.close()

    def __enter__(self: _EventStreamT) -&gt; _EventStreamT:
        self.open()
        return self

    def __exit__(
        self,
        exc_type: typing.Optional[typing.Type[BaseException]],
        exc_val: typing.Optional[BaseException],
        exc_tb: typing.Optional[types.TracebackType],
    ) -&gt; None:
        self.close()

    async def __anext__(self) -&gt; event_manager_.EventT:
        if not self._active:
            raise TypeError(&#34;stream must be started with before entering it&#34;)

        while not self._queue:
            if not self._event:
                self._event = asyncio.Event()

            try:
                await asyncio.wait_for(self._event.wait(), timeout=self._timeout)
            except asyncio.TimeoutError:
                raise StopAsyncIteration from None

            self._event.clear()

        return self._queue.pop(0)

    def __await__(self) -&gt; typing.Generator[None, None, typing.Sequence[event_manager_.EventT]]:
        return self._await_all().__await__()

    def __del__(self) -&gt; None:
        # For the sake of protecting highly intelligent people who forget to close this, we register the event listener
        # with a weakref then try to close this on deletion. While this may lead to their consoles being spammed, this
        # is a small price to pay as it&#39;ll be way more obvious what&#39;s wrong than if we just left them with a vague
        # ominous memory leak.
        if self._active:
            _LOGGER.warning(&#34;active %r streamer fell out of scope before being closed&#34;, self._event_type.__name__)
            self.close()

    async def _await_all(self) -&gt; typing.Sequence[event_manager_.EventT]:
        self.open()
        result = [event async for event in self]
        self.close()
        return result

    async def _listener(self, event: event_manager_.EventT) -&gt; None:
        if not self._filters(event) or (self._limit is not None and len(self._queue) &gt;= self._limit):
            return

        self._queue.append(event)
        if self._event:
            self._event.set()

    def close(self) -&gt; None:
        if self._active and self._registered_listener is not None:
            try:
                self._event_manager.unsubscribe(self._event_type, self._registered_listener)
            except ValueError:
                pass

            self._registered_listener = None

        self._active = False

    def filter(
        self: _EventStreamT,
        *predicates: typing.Union[typing.Tuple[str, typing.Any], typing.Callable[[event_manager_.EventT], bool]],
        **attrs: typing.Any,
    ) -&gt; _EventStreamT:
        filter_ = self._map_predicates_and_attr_getters(&#34;filter&#34;, *predicates, **attrs)
        if self._active:
            self._queue = [entry for entry in self._queue if filter_(entry)]

        self._filters |= filter_
        return self

    def open(self) -&gt; None:
        if not self._active:
            # For the sake of protecting highly intelligent people who forget to close this, we register the event
            # listener with a weakref then try to close this on deletion. While this may lead to their consoles being
            # spammed, this is a small price to pay as it&#39;ll be way more obvious what&#39;s wrong than if we just left them
            # with a vague ominous memory leak.
            reference = weakref.WeakMethod(self._listener)
            listener = _generate_weak_listener(reference)
            self._registered_listener = listener
            self._event_manager.subscribe(self._event_type, listener)
            self._active = True</code></pre>
</details>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="EventStream -- An implementation of an event `EventStream` class …" href="#hikari.impl.event_manager_base.EventStream"
>EventStream</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="EventStream -- A base abstract class for all event streamers …" href="../api/event_manager.html#hikari.api.event_manager.EventStream"
>EventStream</a></dt>
<dd class="nested"><p>A base abstract class for all event streamers …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="../iterators.html#hikari.iterators.LazyIterator"
>LazyIterator</a></dt>
<dd class="nested"><p>A set of results that are fetched asynchronously from the API as needed …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="typing.Generic -- Abstract base class for generic types …" href="https://docs.python.org/3/library/typing.html#typing.Generic"
>Generic</a></dt>
<dd class="nested"><p>Abstract base class for generic types …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<div id="hikari.impl.event_manager_base.EventStream.awaiting" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="awaiting" href="../iterators.html#hikari.iterators.LazyIterator.awaiting" id="hikari.impl.event_manager_base.EventStream.awaiting">awaiting</a>(
    window_size: <a href='https://docs.python.org/3/library/functions.html#int'>int</a> = 10,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="EventStream -- A base abstract class for all event streamers …" href="../api/event_manager.html#hikari.api.event_manager.EventStream"
>EventStream</a></code>.<code><a title="awaiting -- Await each item concurrently in a fixed size window …" href="../iterators.html#hikari.iterators.LazyIterator.awaiting"
>awaiting</a></code>
</p>
<p>Await each item concurrently in a fixed size window.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>window_size</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The window size of how many tasks to await at once. You can set this
to <code>0</code> to await everything at once, but see the below warning.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>LazyIterator[ValueT]</code></dt>
<dd>The new lazy iterator to return.</dd>
</dl>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>Setting a large window size, or setting it to 0 to await everything
is a dangerous thing to do if you are making API calls. Some
endpoints will get ratelimited and cause a backup of waiting
tasks, others may begin to spam global rate limits instead
(the <code>fetch_user</code> endpoint seems to be notorious for doing this).</p>
</div>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This call assumes that the iterator contains awaitable values as
input. MyPy cannot detect this nicely, so any cast is forced
internally.</p>
<p>If the item is not awaitable, you will receive a
<code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code> instead.</p>
<p>You have been warned. You cannot escape the ways of the duck type
young grasshopper.</p>
</div>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.event_manager_base.EventStream.chunk" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="chunk" href="../iterators.html#hikari.iterators.LazyIterator.chunk" id="hikari.impl.event_manager_base.EventStream.chunk">chunk</a>(
    chunk_size: <a href='https://docs.python.org/3/library/functions.html#int'>int</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="EventStream -- A base abstract class for all event streamers …" href="../api/event_manager.html#hikari.api.event_manager.EventStream"
>EventStream</a></code>.<code><a title="chunk -- Return results in chunks of up to `chunk_size` amount of entries …" href="../iterators.html#hikari.iterators.LazyIterator.chunk"
>chunk</a></code>
</p>
<p>Return results in chunks of up to <code>chunk_size</code> amount of entries.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chunk_size</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The limit for how many results should be returned in each chunk.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>LazyIterator[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[ValueT]]</code></dt>
<dd><code>LazyIterator</code> that emits each chunked sequence.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.event_manager_base.EventStream.close" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="close" href="#hikari.impl.event_manager_base.EventStream.close" id="hikari.impl.event_manager_base.EventStream.close">close</a>() -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="EventStream -- A base abstract class for all event streamers …" href="../api/event_manager.html#hikari.api.event_manager.EventStream"
>EventStream</a></code>.<code><a title="close -- Mark this streamer as closed to stop it from queueing and receiving events …" href="../api/event_manager.html#hikari.api.event_manager.EventStream.close"
>close</a></code>
</p>
<p>Mark this streamer as closed to stop it from queueing and receiving events.</p>
<p>If called on an already closed streamer then this will do nothing.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p><code><a href='https://docs.python.org/3/reference/compound_stmts.html#with'>with</a> streamer</code> may be used as a short-cut for opening and
closing a streamer.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/6dbab9a6f401bcf597997b46820717e4dd956c13/hikari/impl/event_manager_base.py#L235-L244" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def close(self) -&gt; None:
    if self._active and self._registered_listener is not None:
        try:
            self._event_manager.unsubscribe(self._event_type, self._registered_listener)
        except ValueError:
            pass

        self._registered_listener = None

    self._active = False</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.event_manager_base.EventStream.collect" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="collect" href="../iterators.html#hikari.iterators.LazyIterator.collect" id="hikari.impl.event_manager_base.EventStream.collect">collect</a>(
    collector: <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]], <a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]],
) -> Collection[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="EventStream -- A base abstract class for all event streamers …" href="../api/event_manager.html#hikari.api.event_manager.EventStream"
>EventStream</a></code>.<code><a title="collect -- Collect the results into a given type and return it …" href="../iterators.html#hikari.iterators.LazyIterator.collect"
>collect</a></code>
</p>
<p>Collect the results into a given type and return it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>collector</code></strong></dt>
<dd>A function that consumes a sequence of values and returns a
collection.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.event_manager_base.EventStream.count" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="count" href="../iterators.html#hikari.iterators.LazyIterator.count" id="hikari.impl.event_manager_base.EventStream.count">count</a>() -> <a href='https://docs.python.org/3/library/functions.html#int'>int</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="EventStream -- A base abstract class for all event streamers …" href="../api/event_manager.html#hikari.api.event_manager.EventStream"
>EventStream</a></code>.<code><a title="count -- Count the number of results …" href="../iterators.html#hikari.iterators.LazyIterator.count"
>count</a></code>
</p>
<p>Count the number of results.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>Number of results found.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.event_manager_base.EventStream.enumerate" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="enumerate" href="../iterators.html#hikari.iterators.LazyIterator.enumerate" id="hikari.impl.event_manager_base.EventStream.enumerate">enumerate</a>(
    *,
    start: <a href='https://docs.python.org/3/library/functions.html#int'>int</a> = 0,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>, ~<a href='#hikari.iterators.ValueT'>ValueT</a>]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="EventStream -- A base abstract class for all event streamers …" href="../api/event_manager.html#hikari.api.event_manager.EventStream"
>EventStream</a></code>.<code><a title="enumerate -- Enumerate the paginated results lazily …" href="../iterators.html#hikari.iterators.LazyIterator.enumerate"
>enumerate</a></code>
</p>
<p>Enumerate the paginated results lazily.</p>
<p>This behaves as an asyncio-friendly version of <code><a href='https://docs.python.org/3/library/functions.html#enumerate'>enumerate</a></code>
which uses much less memory than collecting all the results first and
calling <code><a href='https://docs.python.org/3/library/functions.html#enumerate'>enumerate</a></code> across them.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>start</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>Optional int to start at. If omitted, this is <code>0</code>.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; async for i, item in paginated_results.enumerate():
...    print(i, item)
(0, foo)
(1, bar)
(2, baz)
(3, bork)
(4, qux)

&gt;&gt;&gt; async for i, item in paginated_results.enumerate(start=9):
...    print(i, item)
(9, foo)
(10, bar)
(11, baz)
(12, bork)
(13, qux)

&gt;&gt;&gt; async for i, item in paginated_results.enumerate(start=9).limit(3):
...    print(i, item)
(9, foo)
(10, bar)
(11, baz)
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>LazyIterator[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>, T]]</code></dt>
<dd>A paginated results view that asynchronously yields an increasing
counter in a tuple with each result, lazily.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.event_manager_base.EventStream.filter" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="filter" href="#hikari.impl.event_manager_base.EventStream.filter" id="hikari.impl.event_manager_base.EventStream.filter">filter</a>(
    self: _EventStreamT,
    *predicates: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[event_manager_.EventT], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]],
    **attrs: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>,
) -> _EventStreamT: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="EventStream -- A base abstract class for all event streamers …" href="../api/event_manager.html#hikari.api.event_manager.EventStream"
>EventStream</a></code>.<code><a title="filter -- Filter the items by one or more conditions …" href="../api/event_manager.html#hikari.api.event_manager.EventStream.filter"
>filter</a></code>
</p>
<p>Filter the items by one or more conditions.</p>
<p>Each condition is treated as a predicate, being called with each item
that this iterator would return when it is requested.</p>
<p>All conditions must evaluate to <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> for the item to be
returned. If this is not met, then the item is discarded and ignored,
the next matching item will be returned instead, if there is one.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*predicates</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[ValueT], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]]</code></dt>
<dd>Predicates to invoke. These are functions that take a value and
return <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> if it is of interest, or <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>
otherwise. These may instead include 2-<code><a href='https://docs.python.org/3/library/stdtypes.html#tuple'>tuple</a></code> objects
consisting of a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> attribute name (nested attributes
are referred to using the <code>.</code> operator), and values to compare for
equality. This allows you to specify conditions such as
<code>members.filter(("user.bot", <a href='https://docs.python.org/3/library/constants.html#True'>True</a>))</code>.</dd>
<dt><strong><code>**attrs</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a></code></dt>
<dd>Alternative to passing 2-tuples. Cannot specify nested attributes
using this method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.impl.event_manager_base.EventStream'>EventStream</a>[ValueT]</code></dt>
<dd>The current stream with the new filter applied.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/6dbab9a6f401bcf597997b46820717e4dd956c13/hikari/impl/event_manager_base.py#L246-L256" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def filter(
    self: _EventStreamT,
    *predicates: typing.Union[typing.Tuple[str, typing.Any], typing.Callable[[event_manager_.EventT], bool]],
    **attrs: typing.Any,
) -&gt; _EventStreamT:
    filter_ = self._map_predicates_and_attr_getters(&#34;filter&#34;, *predicates, **attrs)
    if self._active:
        self._queue = [entry for entry in self._queue if filter_(entry)]

    self._filters |= filter_
    return self</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.event_manager_base.EventStream.flat_map" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="flat_map" href="../iterators.html#hikari.iterators.LazyIterator.flat_map" id="hikari.impl.event_manager_base.EventStream.flat_map">flat_map</a>(
    flattener: _FlattenerT[<a href='#hikari.iterators.ValueT'>ValueT</a>, <a href='#hikari.iterators.AnotherValueT'>AnotherValueT</a>],
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.AnotherValueT'>AnotherValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="EventStream -- A base abstract class for all event streamers …" href="../api/event_manager.html#hikari.api.event_manager.EventStream"
>EventStream</a></code>.<code><a title="flat_map -- Perform a flat mapping operation …" href="../iterators.html#hikari.iterators.LazyIterator.flat_map"
>flat_map</a></code>
</p>
<p>Perform a flat mapping operation.</p>
<p>This will pass each item in the iterator to the given <code><a href='https://docs.python.org/3/reference/compound_stmts.html#function'>function</a></code>
parameter, expecting a new <code><a href='https://docs.python.org/3/library/typing.html#typing.Iterable'>Iterable</a></code> or <code><a href='https://docs.python.org/3/library/typing.html#typing.AsyncIterator'>AsyncIterator</a></code>
to be returned as the result. This means you can map to a new
<code>LazyIterator</code>, <code><a href='https://docs.python.org/3/library/typing.html#typing.AsyncIterator'>AsyncIterator</a></code>, <code><a href='https://docs.python.org/3/library/typing.html#typing.Iterable'>Iterable</a></code>,
async generator, or generator.</p>
<p>Remember that <code><a href='https://docs.python.org/3/library/typing.html#typing.Iterator'>Iterator</a></code> implicitly provides <code><a href='https://docs.python.org/3/library/typing.html#typing.Iterable'>Iterable</a></code>
compatibility.</p>
<p>This is used to provide lazy conversions, and can be used to implement
reactive-like pipelines if desired.</p>
<p>All results are combined into one large lazy iterator and yielded
lazily.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>flattener</code></strong></dt>
<dd>A function that returns either an async iterator or iterator of
new values. Could be an attribute name instead.</dd>
</dl>
<h2 id="example">Example</h2>
<p>The following example generates a distinct collection of all mentioned
users in the given channel from the past 500 messages.</p>
<pre><code class="language-py">def iter_mentioned_users(message: hikari.Message) -&gt; typing.Iterable[Snowflake]:
    for match in re.findall(r&quot;&lt;@!?(\d+)&gt;&quot;, message.content):
        yield Snowflake(match)

mentioned_users = await (
    channel
    .history()
    .limit(500)
    .map(&quot;.content&quot;)
    .flat_map(iter_mentioned_users)
    .distinct()
)
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>LazyIterator[AnotherValueT]</code></dt>
<dd>The new lazy iterator to return.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.event_manager_base.EventStream.for_each" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="for_each" href="../iterators.html#hikari.iterators.LazyIterator.for_each" id="hikari.impl.event_manager_base.EventStream.for_each">for_each</a>(
    consumer: <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="EventStream -- A base abstract class for all event streamers …" href="../api/event_manager.html#hikari.api.event_manager.EventStream"
>EventStream</a></code>.<code><a title="for_each -- Pass each value to a given consumer immediately." href="../iterators.html#hikari.iterators.LazyIterator.for_each"
>for_each</a></code>
</p>
<p>Pass each value to a given consumer immediately.</p>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.event_manager_base.EventStream.last" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="last" href="../iterators.html#hikari.iterators.LazyIterator.last" id="hikari.impl.event_manager_base.EventStream.last">last</a>() -> ~<a href='#hikari.iterators.ValueT'>ValueT</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="EventStream -- A base abstract class for all event streamers …" href="../api/event_manager.html#hikari.api.event_manager.EventStream"
>EventStream</a></code>.<code><a title="last -- Return the last element of this iterator only …" href="../iterators.html#hikari.iterators.LazyIterator.last"
>last</a></code>
</p>
<p>Return the last element of this iterator only.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ValueT</code></dt>
<dd>The last result.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This method will consume the whole iterator if run.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#LookupError'>LookupError</a></code></dt>
<dd>If no result exists.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.event_manager_base.EventStream.limit" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="limit" href="../iterators.html#hikari.iterators.LazyIterator.limit" id="hikari.impl.event_manager_base.EventStream.limit">limit</a>(
    limit: <a href='https://docs.python.org/3/library/functions.html#int'>int</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="EventStream -- A base abstract class for all event streamers …" href="../api/event_manager.html#hikari.api.event_manager.EventStream"
>EventStream</a></code>.<code><a title="limit -- Limit the number of items you receive from this async iterator …" href="../iterators.html#hikari.iterators.LazyIterator.limit"
>limit</a></code>
</p>
<p>Limit the number of items you receive from this async iterator.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>limit</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The number of items to get. This must be greater than zero.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; async for item in paginated_results.limit(3):
...     print(item)
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>LazyIterator[ValueT]</code></dt>
<dd>A paginated results view that asynchronously yields a maximum
of the given number of items before completing.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.event_manager_base.EventStream.map" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="map" href="../iterators.html#hikari.iterators.LazyIterator.map" id="hikari.impl.event_manager_base.EventStream.map">map</a>(
    transformation: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='#hikari.iterators.AnotherValueT'>AnotherValueT</a>], <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>],
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.AnotherValueT'>AnotherValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="EventStream -- A base abstract class for all event streamers …" href="../api/event_manager.html#hikari.api.event_manager.EventStream"
>EventStream</a></code>.<code><a title="map -- Map the values to a different value …" href="../iterators.html#hikari.iterators.LazyIterator.map"
>map</a></code>
</p>
<p>Map the values to a different value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>transformation</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[ValueT], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>], <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>The function to use to map the attribute. This may alternatively
be a string attribute name to replace the input value with. You
can provide nested attributes using the <code>.</code> operator.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>LazyIterator[AnotherValueT]</code></dt>
<dd><code>LazyIterator</code> that maps each value to another value.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.event_manager_base.EventStream.next" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="next" href="../iterators.html#hikari.iterators.LazyIterator.next" id="hikari.impl.event_manager_base.EventStream.next">next</a>() -> ~<a href='#hikari.iterators.ValueT'>ValueT</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="EventStream -- A base abstract class for all event streamers …" href="../api/event_manager.html#hikari.api.event_manager.EventStream"
>EventStream</a></code>.<code><a title="next -- Return the next element of this iterator only …" href="../iterators.html#hikari.iterators.LazyIterator.next"
>next</a></code>
</p>
<p>Return the next element of this iterator only.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ValueT</code></dt>
<dd>The next result.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#LookupError'>LookupError</a></code></dt>
<dd>If no more results exist.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.event_manager_base.EventStream.open" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="open" href="#hikari.impl.event_manager_base.EventStream.open" id="hikari.impl.event_manager_base.EventStream.open">open</a>() -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="EventStream -- A base abstract class for all event streamers …" href="../api/event_manager.html#hikari.api.event_manager.EventStream"
>EventStream</a></code>.<code><a title="open -- Mark this streamer as opened to let it start receiving and queueing events …" href="../api/event_manager.html#hikari.api.event_manager.EventStream.open"
>open</a></code>
</p>
<p>Mark this streamer as opened to let it start receiving and queueing events.</p>
<p>If called on an already started streamer then this will do nothing.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p><code><a href='https://docs.python.org/3/reference/compound_stmts.html#with'>with</a> streamer</code> may be used as a short-cut for opening and
closing a stream.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/6dbab9a6f401bcf597997b46820717e4dd956c13/hikari/impl/event_manager_base.py#L258-L268" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def open(self) -&gt; None:
    if not self._active:
        # For the sake of protecting highly intelligent people who forget to close this, we register the event
        # listener with a weakref then try to close this on deletion. While this may lead to their consoles being
        # spammed, this is a small price to pay as it&#39;ll be way more obvious what&#39;s wrong than if we just left them
        # with a vague ominous memory leak.
        reference = weakref.WeakMethod(self._listener)
        listener = _generate_weak_listener(reference)
        self._registered_listener = listener
        self._event_manager.subscribe(self._event_type, listener)
        self._active = True</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.event_manager_base.EventStream.reversed" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="reversed" href="../iterators.html#hikari.iterators.LazyIterator.reversed" id="hikari.impl.event_manager_base.EventStream.reversed">reversed</a>() -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="EventStream -- A base abstract class for all event streamers …" href="../api/event_manager.html#hikari.api.event_manager.EventStream"
>EventStream</a></code>.<code><a title="reversed -- Return a lazy iterator of the remainder of this iterator's values reversed …" href="../iterators.html#hikari.iterators.LazyIterator.reversed"
>reversed</a></code>
</p>
<p>Return a lazy iterator of the remainder of this iterator's values reversed.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>LazyIterator[ValueT]</code></dt>
<dd>The lazy iterator of this iterator's remaining values reversed.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.event_manager_base.EventStream.skip" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="skip" href="../iterators.html#hikari.iterators.LazyIterator.skip" id="hikari.impl.event_manager_base.EventStream.skip">skip</a>(
    number: <a href='https://docs.python.org/3/library/functions.html#int'>int</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="EventStream -- A base abstract class for all event streamers …" href="../api/event_manager.html#hikari.api.event_manager.EventStream"
>EventStream</a></code>.<code><a title="skip -- Drop the given number of items, then yield anything after …" href="../iterators.html#hikari.iterators.LazyIterator.skip"
>skip</a></code>
</p>
<p>Drop the given number of items, then yield anything after.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>number</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The max number of items to drop before any items are yielded.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>LazyIterator[ValueT]</code></dt>
<dd>A paginated results view that asynchronously yields all items
AFTER the given number of items are discarded first.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.event_manager_base.EventStream.skip_until" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="skip_until" href="../iterators.html#hikari.iterators.LazyIterator.skip_until" id="hikari.impl.event_manager_base.EventStream.skip_until">skip_until</a>(
    *predicates: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]],
    **attrs: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="EventStream -- A base abstract class for all event streamers …" href="../api/event_manager.html#hikari.api.event_manager.EventStream"
>EventStream</a></code>.<code><a title="skip_until -- Discard items while all conditions are False …" href="../iterators.html#hikari.iterators.LazyIterator.skip_until"
>skip_until</a></code>
</p>
<p>Discard items while all conditions are False.</p>
<p>Items after this will be yielded as normal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*predicates</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[ValueT], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]]</code></dt>
<dd>Predicates to invoke. These are functions that take a value and
return <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> if it is of interest, or <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>
otherwise. These may instead include 2-<code><a href='https://docs.python.org/3/library/stdtypes.html#tuple'>tuple</a></code> objects
consisting of a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> attribute name (nested attributes are
referred to using the <code>.</code> operator), and values to compare for
equality. This allows you to specify conditions such as
<code>members.skip_until(("user.bot", <a href='https://docs.python.org/3/library/constants.html#True'>True</a>))</code>.</dd>
<dt><strong><code>**attrs</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a></code></dt>
<dd>Alternative to passing 2-tuples. Cannot specify nested attributes
using this method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>LazyIterator[ValueT]</code></dt>
<dd>LazyIterator that only emits values once a condition has failed.
All items before this are discarded.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.event_manager_base.EventStream.skip_while" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="skip_while" href="../iterators.html#hikari.iterators.LazyIterator.skip_while" id="hikari.impl.event_manager_base.EventStream.skip_while">skip_while</a>(
    *predicates: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]],
    **attrs: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="EventStream -- A base abstract class for all event streamers …" href="../api/event_manager.html#hikari.api.event_manager.EventStream"
>EventStream</a></code>.<code><a title="skip_while -- Discard items while all conditions are True …" href="../iterators.html#hikari.iterators.LazyIterator.skip_while"
>skip_while</a></code>
</p>
<p>Discard items while all conditions are True.</p>
<p>Items after this will be yielded as normal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*predicates</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[ValueT], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]]</code></dt>
<dd>Predicates to invoke. These are functions that take a value and
return <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> if it is of interest, or <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>
otherwise. These may instead include 2-<code><a href='https://docs.python.org/3/library/stdtypes.html#tuple'>tuple</a></code> objects
consisting of a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> attribute name (nested attributes
are referred to using the <code>.</code> operator), and values to compare for
equality. This allows you to specify conditions such as
<code>members.skip_while(("user.bot", <a href='https://docs.python.org/3/library/constants.html#True'>True</a>))</code>.</dd>
<dt><strong><code>**attrs</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a></code></dt>
<dd>Alternative to passing 2-tuples. Cannot specify nested attributes
using this method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>LazyIterator[ValueT]</code></dt>
<dd>LazyIterator that only emits values once a condition has been met.
All items before this are discarded.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.event_manager_base.EventStream.sort" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="sort" href="../iterators.html#hikari.iterators.LazyIterator.sort" id="hikari.impl.event_manager_base.EventStream.sort">sort</a>(
    *,
    key: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a> = None,
    reverse: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a> = False,
) -> Sequence[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="EventStream -- A base abstract class for all event streamers …" href="../api/event_manager.html#hikari.api.event_manager.EventStream"
>EventStream</a></code>.<code><a title="sort -- Collect all results, then sort the collection before returning it." href="../iterators.html#hikari.iterators.LazyIterator.sort"
>sort</a></code>
</p>
<p>Collect all results, then sort the collection before returning it.</p>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.event_manager_base.EventStream.take_until" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="take_until" href="../iterators.html#hikari.iterators.LazyIterator.take_until" id="hikari.impl.event_manager_base.EventStream.take_until">take_until</a>(
    *predicates: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]],
    **attrs: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="EventStream -- A base abstract class for all event streamers …" href="../api/event_manager.html#hikari.api.event_manager.EventStream"
>EventStream</a></code>.<code><a title="take_until -- Return each item until any conditions pass or the end is reached …" href="../iterators.html#hikari.iterators.LazyIterator.take_until"
>take_until</a></code>
</p>
<p>Return each item until any conditions pass or the end is reached.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*predicates</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[ValueT], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]]</code></dt>
<dd>Predicates to invoke. These are functions that take a value and
return <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> if it is of interest, or <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>
otherwise. These may instead include 2-<code><a href='https://docs.python.org/3/library/stdtypes.html#tuple'>tuple</a></code> objects
consisting of a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> attribute name (nested attributes are
referred to using the <code>.</code> operator), and values to compare for
equality. This allows you to specify conditions such as
<code>members.take_until(("user.bot", <a href='https://docs.python.org/3/library/constants.html#True'>True</a>))</code>.</dd>
<dt><strong><code>**attrs</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a></code></dt>
<dd>Alternative to passing 2-tuples. Cannot specify nested attributes
using this method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>LazyIterator[ValueT]</code></dt>
<dd>LazyIterator that only emits values until any conditions are
matched.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.event_manager_base.EventStream.take_while" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="take_while" href="../iterators.html#hikari.iterators.LazyIterator.take_while" id="hikari.impl.event_manager_base.EventStream.take_while">take_while</a>(
    *predicates: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]],
    **attrs: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="EventStream -- A base abstract class for all event streamers …" href="../api/event_manager.html#hikari.api.event_manager.EventStream"
>EventStream</a></code>.<code><a title="take_while -- Return each item until any conditions fail or the end is reached …" href="../iterators.html#hikari.iterators.LazyIterator.take_while"
>take_while</a></code>
</p>
<p>Return each item until any conditions fail or the end is reached.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*predicates</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[ValueT], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]]</code></dt>
<dd>Predicates to invoke. These are functions that take a value and
return <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> if it is of interest, or <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>
otherwise. These may instead include 2-<code><a href='https://docs.python.org/3/library/stdtypes.html#tuple'>tuple</a></code> objects
consisting of a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> attribute name (nested attributes
are referred to using the <code>.</code> operator), and values to compare for
equality. This allows you to specify conditions such as
<code>members.take_while(("user.bot", <a href='https://docs.python.org/3/library/constants.html#True'>True</a>))</code>.</dd>
<dt><strong><code>**attrs</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a></code></dt>
<dd>Alternative to passing 2-tuples. Cannot specify nested attributes
using this method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>LazyIterator[ValueT]</code></dt>
<dd>LazyIterator that only emits values until any conditions are not
matched.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</div>
</dl>
</section>
</div>
</div>
</div>
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>